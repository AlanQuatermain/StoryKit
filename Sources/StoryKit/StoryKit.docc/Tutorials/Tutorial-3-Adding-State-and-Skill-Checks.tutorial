@Intro(title: "Checks, Effects, Actions, Battles, and the Ritual") {
    In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.

    StoryKit is deliberately agnostic to any specific game engine. It focuses on node‑to‑node flow and flexible metadata, while leaving rules and systems to your app. Because mechanics live in your client, the same story can drive very different experiences—your rules decide what “has‑item”, “lose‑sanity”, or “ritual” mean. Content stays declarative and portable; you can validate and iterate without recompiling your app.

    By the end, your CLI will present checks with narrative feedback, support short fights with a chance to flee, and enforce a ritual’s required items and order. You’ll also wire autosave so progress survives between rounds and after risky choices.
}

@Section(title: "Designing Game State") {
    @ContentAndMedia {
        Treat your `StoryState` like a character sheet. It’s the single source of truth for stats (health, sanity), inventory (item ids), and flags. Keeping this in your app means you can evolve mechanics freely while the story stays declarative and portable. It’s also what lets StoryKit be engine‑agnostic: it handles node flow and metadata, and your client supplies the rules.

        Keep the state `Codable`/`Sendable` and add small helpers—`gain(_:)`, `has(_:)`, `setFlag(_:to:)`—so updates are clear and safe.
    }
    @Steps {
        @Step {
            Extend `HauntedState` with fields and helpers. Initialize conservative defaults and prefer value semantics.

            @Code(name: "HauntedState (extended)", file: 03-01-HauntedState-Extended.swift)
        }
    }
}

@Section(title: "Roll-Under Checks & Predicates") {
    @ContentAndMedia {
        Roll‑under checks fit horror because success is often narrow and failure meaningful. Add a simple `rollD20()` and a helper that evaluates “under X” for a stat. Then register predicates for gating: `has-item` and a generic `stat-at-least` are immediately useful and map cleanly from authored parameters to code. Predicates are pure: they read state and parameters and return a Bool.
    }
    @Steps {
        @Step {
            Add the dice and check helpers, and register `has-item` and `stat-at-least` into a `PredicateRegistry`.

            @Code(name: "Checks & Predicates", file: 03-02-ChecksAndPredicates.swift)
        }
    }
}

@Section(title: "Effects: Damage, Sanity, Items, Flags") {
    @ContentAndMedia {
        Effects are deterministic state changes invoked on selection or on‑enter. Keep them small and composable, and map string parameters to integers and booleans carefully. This is where narrative consequences become concrete: a sanity drop, an injury, an inventory gain, a flag that opens later branches.
    }
    @Steps {
        @Step {
            Register `lose-sanity`, `take-damage`, `gain-item`, and `set-flag`. Favor clamping to safe ranges and defensive parsing of parameters.

            @Code(name: "Effects", file: 03-03-Effects.swift)
        }
    }
}

@Section(title: "Entities & Multi-Round Battles with Flee") {
    @ContentAndMedia {
        Encounters benefit from pacing. A melee round should produce narration, potentially modify state (damage to player or enemy), and offer a flee option keyed to a check. Model opponents minimally—hp, attack range, name—and drive the action through an `ActionRegistry` closure. Return `.requiresUserInput` when the fight continues; return `.completed` when it ends.
    }
    @Steps {
        @Step {
            Define a tiny entity model and register a `melee-round` action that advances a fight, handles misses/retaliation, and supports flee with a roll–under gate.

            @Code(name: "Battle System", file: 03-04-BattleSystem.swift)
        }
    }
}

@Section(title: "The Final Ritual (Ordered Sequence)") {
    @ContentAndMedia {
        The ritual requires multiple items and a strict order. Author the action as a single `ritual` id that accepts an `order` parameter (comma‑joined steps). In code, verify inventory and order; set flags to route to outcomes. This keeps branching logic out of the story graph while preserving authoring clarity.
    }
    @Steps {
        @Step {
            Register a `ritual` action that checks for the Black Candle, Forbidden Tome, and Silver Dagger, validates the item order (candle → tome → dagger), and toggles outcome flags.

            @Code(name: "Ritual", file: 03-05-Ritual.swift)
        }
    }
}

@Section(title: "Autosave Between Rounds") {
    @ContentAndMedia {
        Long encounters and risky sequences should persist. Use `JSONFileSaveProvider` with `makeAutoSaveHandler` to write a snapshot after transitions and actions. The engine’s `autosave` closure is invoked after successful `select` and `performAction` calls.
    }
    @Steps {
        @Step {
            Create a small factory for an autosave closure keyed by a story id and slot name. In your engine construction, pass it as `autosave:`.

            @Code(name: "Autosave", file: 03-06-AutoSave.swift)
        }
    }
}

@Section(title: "Outcome") {
    @ContentAndMedia {
        Your CLI now supports checks, registered predicates/effects, a multi‑round melee action with flee, the ordered ritual, and autosave. Mechanics stay in your client while content stays declarative and portable; StoryKit remains agnostic to the game engine and focused on node flow and metadata.
    }
    @Steps {
        @Step {
            You can now enrich narration, route results to specialized nodes, or transition via `performGlobalAction` to endings—without changing the story’s structure. Next up, you can refine rules, make checks probabilistic or stat‑driven, and expand encounters, all while StoryKit continues to handle traversal, loading, and validation.
        }
    }
}
