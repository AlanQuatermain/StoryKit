@Tutorial(time: 60, projectFiles: ["HauntedHouseBundle.zip"]) {
  @Intro(title: "Checks, Effects, Actions, Battles, and the Ritual") {
    In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.

    StoryKit is deliberately agnostic to any specific game engine. It focuses on node‑to‑node flow and flexible metadata, while leaving rules and systems to your app. Because mechanics live in your client, the same story can drive very different experiences—your rules decide what “has‑item”, “lose‑sanity”, or “ritual” mean. Content stays declarative and portable; you can validate and iterate without recompiling your app.

    By the end, your CLI will present checks with narrative feedback, support short fights with a chance to flee, and enforce a ritual’s required items and order. You’ll also wire autosave so progress survives between rounds and after risky choices.
  }

  @Section(title: "Designing Game State") {
    @ContentAndMedia {
      Treat your `StoryState` like a character sheet. It's the single source of truth for stats (health, sanity), inventory (item ids), and flags. Keeping this in your app means you can evolve mechanics freely while the story stays declarative and portable. It's also what lets StoryKit be engine‑agnostic: it handles node flow and metadata, and your client supplies the rules.

      We'll build it up in small steps so each addition is obvious and testable, then demonstrate advanced patterns with custom structures for complex mechanics.
    }
    @Steps {
      @Step {
        Start with a minimal state that only satisfies the engine: a `currentNode`.

        @Code(name: "HauntedState.swift", file: HauntedState.swift)
      }
      @Step {
        Add fields you'll use throughout the story: `health`, `sanity`, `inventory`, and `flags`.

        @Code(name: "HauntedState.swift", file: HauntedState@2.swift)
      }
      @Step {
        Add tiny helpers so updates are safe and readable: `gain(_:)`, `has(_:)`, and `setFlag(_:to:)`.

        @Code(name: "HauntedState.swift", file: HauntedState@3.swift)
      }
      @Step {
        For complex mechanics, create dedicated structures. Add a `Ritual` struct to track multi‑step sequences properly.

        @Code(name: "HauntedState.swift", file: HauntedState@4.swift)
      }
      @Step {
        Add a `BoneServant` struct for chase mechanics, demonstrating how structured state management scales to advanced game systems.

        @Code(name: "HauntedState.swift", file: HauntedState@5.swift)
      }
      @Step {
        Add methods to the `Ritual` struct to encapsulate the logic for each ritual step with proper validation.

        @Code(name: "HauntedState.swift", file: HauntedState@6.swift)
      }
      @Step {
        Complete the `Ritual` methods to support the full three‑step sequence: candle, tome, sacrifice.

        @Code(name: "HauntedState.swift", file: HauntedState@7.swift)
      }
      @Step {
        Finalize the state design with the complete `Ritual` struct including the final sacrifice method that activates the bone servant.

        @Code(name: "HauntedState.swift", file: HauntedState@8.swift)
      }
    }
  }

  @Section(title: "Roll-Under Checks & Predicates") {
    @ContentAndMedia {
      Roll‑under checks fit horror because success is often narrow and failure meaningful. We’ll add a tiny dice helper, then register two useful predicates. Predicates are pure: they read state and parameters and return a Bool.
    }
    @Steps {
      @Step {
        Add a `rollD20()` and a `checkUnder(_:)` helper to support roll‑under checks.

        @Code(name: "Predicates.swift", file: Predicates.swift)
      }
      @Step {
        Register a `has-item` predicate that maps directly to your inventory semantics.

        @Code(name: "Predicates.swift", file: Predicates@2.swift)
      }
      @Step {
        Register a `stat-at-least` predicate that compares a stat to a threshold provided in parameters.

        @Code(name: "Predicates.swift", file: Predicates@3.swift)
      }
    }
  }

  @Section(title: "Effects: Damage, Sanity, Items, Flags") {
    @ContentAndMedia {
      Effects are deterministic state changes invoked on selection or on‑enter. Keep them small and composable, and map string parameters to integers and booleans carefully. This is where narrative consequences become concrete: a sanity drop, an injury, an inventory gain, a flag that opens later branches.
    }
    @Steps {
      @Step {
        Register a `lose-sanity` effect. Clamp values to safe ranges so state never goes out of bounds.

        @Code(name: "Effects.swift", file: Effects.swift)
      }
      @Step {
        Register a `take-damage` effect. Again, clamp to keep state valid.

        @Code(name: "Effects.swift", file: Effects@2.swift)
      }
      @Step {
        Register a `gain-item` effect. Treat inventory additions as idempotent.

        @Code(name: "Effects.swift", file: Effects@3.swift)
      }
      @Step {
        Register a `set-flag` effect. Flags open later branches.

        @Code(name: "Effects.swift", file: Effects@4.swift)
      }
    }
  }

  @Section(title: "Chase Mechanics & Bone Servant Encounters") {
    @ContentAndMedia {
      Advanced encounters benefit from structured mechanics. The bone servant represents a persistent threat that tracks the player through multiple rooms. Model this using dedicated structures and actions that work with those structures through extensions.
    }
    @Steps {
      @Step {
        Create an extension to organize bone servant actions. Start with the basic structure.

        @Code(name: "Battle.swift", file: Battle.swift)
      }
      @Step {
        Register a `check_pursuit` action that advances the chase and checks if the bone servant has arrived.

        @Code(name: "Battle.swift", file: Battle@2.swift)
      }
      @Step {
        Add flee support for escaping the bone servant using a dexterity check. Reset the servant on successful escape.

        @Code(name: "Battle.swift", file: Battle@3.swift)
      }
    }
  }

  @Section(title: "The Final Ritual (Individual Actions)") {
    @ContentAndMedia {
      The ritual requires multiple items and a strict sequence of individual actions. Rather than a single action with ordering parameters, implement each step as its own action that works with the `Ritual` struct methods. This provides clearer narrative control and better user experience.
    }
    @Steps {
      @Step {
        Create an extension to organize ritual actions. Start with the basic structure.

        @Code(name: "Ritual.swift", file: Ritual.swift)
      }
      @Step {
        Register the `light_candle` action that validates inventory and calls the appropriate `Ritual` method.

        @Code(name: "Ritual.swift", file: Ritual@2.swift)
      }
      @Step {
        Add the `read_tome` action that enforces the proper sequence through the `Ritual` struct's logic.

        @Code(name: "Ritual.swift", file: Ritual@3.swift)
      }
      @Step {
        Complete the ritual with `make_sacrifice` action that activates the bone servant on successful completion.

        @Code(name: "Ritual.swift", file: Ritual@4.swift)
      }
    }
  }

  @Section(title: "Autosave Between Rounds") {
    @ContentAndMedia {
      Long encounters and risky sequences should persist. Use `JSONFileSaveProvider` with `makeAutoSaveHandler` to write a snapshot after transitions and actions. The engine’s `autosave` closure is invoked after successful `select` and `performAction` calls.
    }
    @Steps {
      @Step {
        Create a small factory for an autosave closure keyed by a story id and slot name.

        @Code(name: "AutoSave.swift", file: AutoSave.swift)
      }
      @Step {
        Pass the closure to `StoryEngine` as `autosave:` when you construct the engine.

        @Code(name: "AutoSave.swift", file: AutoSave@2.swift)
      }
    }
  }

  @Section(title: "Outcome") {
    @ContentAndMedia {
      Your CLI now supports checks, registered predicates/effects, a multi‑round melee action with flee, the ordered ritual, and autosave. Mechanics stay in your client while content stays declarative and portable; StoryKit remains agnostic to the game engine and focused on node flow and metadata.
    }
    @Steps {
      @Step {
        You can now enrich narration, route results to specialized nodes, or transition via `performGlobalAction` to endings—without changing the story’s structure. Next up, you can refine rules, make checks probabilistic or stat‑driven, and expand encounters, all while StoryKit continues to handle traversal, loading, and validation.
      }
    }
  }
}
