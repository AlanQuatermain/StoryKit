@Tutorial(time: 30, projectFiles: ["HauntedStarter.zip"]) {
  @Intro(title: "Building and Validating a Story") {
    In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.

    The goals are practical and conceptual. Practically, you’ll learn how `story.json` declares nodes and choices, how Markdown sections provide prose for each node, and how compiled `.storybundle` directories package everything an app needs. Conceptually, you’ll see how the validator’s structural, flow, and content checks help you spot missing starts, duplicate choice identifiers, bad destinations, and mismatches between your graph and your Markdown.
  }

  @Section(title: "StoryKit File Formats") {
    @ContentAndMedia {
      StoryKit authoring centers on three artifacts that work together: the story graph (`story.json`), prose (`texts/*.md`), and compiled bundles (`.storybundle`). Keeping these boundaries clean makes iteration fast and validation meaningful.

      1. `story.json` is the brain: it declares a starting node (`start`) and a dictionary of `nodes`. Each node includes an `id`, a `text` reference pointing to Markdown (`file` + `section`), a list of `choices` (each with an `id` and a `destination`), and optional predicate/effect descriptors and declarative `actors`. The file is canonical for traversal and static checks.
      2. Markdown is the voice: each file in `texts/` can hold multiple node sections, delimited by lines like `=== node: foyer ===`. This is where you write prose that breathes—multi–paragraph descriptions, atmospheric beats, and encounter narration. The `TextSectionParser` splits big files into section maps at load time.
      3. A `.storybundle` is the runtime package: it contains `manifest.json` (metadata + `graph.json` hash), `graph.json` (a compiled copy of the story JSON), and a `texts/` folder copied from source. Apps load bundles with `StoryBundleLoader` to avoid touching your authoring directory structure at runtime.

      Below are small excerpts. Your real files will be larger, but these convey the schema and the Markdown delimiter.
    }
    @Steps {
      @Step {
        Inspect a minimal `story.json` excerpt.

        @Code(name: "story.json", file: 01-format-story.json)
      }
      @Step {
        Inspect a Markdown file with multiple node sections.

        @Code(name: "haunted.md", file: 01-format-haunted.txt)
      }
      @Step {
        Inspect a compiled bundle directory layout.

        @Code(name: "bundle structure", file: 01-format-bundle.txt)
      }
    }
  }

  @Section(title: "Validating a Story") {
    @ContentAndMedia {
      The validator is exposed through the `storykit` CLI. It loads either a source folder (containing `story.json` and `texts/`) or a compiled bundle (containing `manifest.json`, `graph.json`, and `texts/`). By default, the text output lists warnings and errors. JSON output includes counts and a serializable issue list, and the tool exits non‑zero on errors so you can use it in CI.
    }
    @Steps {
      @Step {
        Download the starter files and unzip them into a convenient folder (for example, `~/Downloads/HauntedStarter`). You’ll pass this folder to the validator and compiler.
      }
      @Step {
        Build the package and run the validator from the root of the StoryKit checkout: `swift build` then `swift run storykit validate ~/Downloads/HauntedStarter --format text`. The output will list structural and content issues to fix.

        @Code(name: "validator.txt", file: 02-validate-errors.txt)
      }
    }
  }

  @Section(title: "Story Node Structure") {
    @ContentAndMedia {
      The validator reported three structure problems in `story.json`:

      - A missing `start` field: every story needs a “first page” so the engine knows where to begin.
      - A duplicate choice id under one node: two choices shared the same name, which makes it unclear which path the player picked.
      - A missing destination: a choice pointed to a node id that doesn’t exist — often a simple typo.

      Fix each issue below and validate after each change.
    }
    @Steps {
      @Step {
        Set the start node. The story engine needs to know which node to begin the story at, and you want to begin outside the house, so you set the starting node to `arrival_road`.

        @Code(name: "story.json", file: 03-after-with-start.json)
      }
      @Step {
        Make duplicate choice ids unique. All choice ids under a node need to be unique. In the starter files, `to_dining` appeared twice. Change one of them to `to_study` so each choice has its own name.

        @Code(name: "story.json", file: 03-after-duplicate-choices.json)
      }
      @Step {
        Fix the misspelled destination. A choice pointed to `end_succesful`. This looks like a simple typo — it’s missing an “S”. Correct it to `end_successful` so the choice leads to a real node.

        @Code(name: "story.json", file: 03-after-dest-typo.json)
      }
      @Step {
        Validate again after the JSON fixes. At this point the structure is sound; what remains are text issues in Markdown: a missing `dining_room` section and an orphan `attic_extra` section.

        @Code(name: "validator.txt", file: 03-validate-after-json.txt)
      }
    }
  }

  @Section(title: "Text Content") {
    @ContentAndMedia {
      With the graph repaired, turn to prose. The validator reported two Markdown issues:

      - A missing `dining_room` section: a node references prose that isn’t present; every node needs matching text.
      - An orphan `attic_extra` section: no node connects to it. It’s likely a left‑over from an encounter that was discarded, so remove the section completely.
    }
    @Steps {
      @Step {
        Restore the missing section and remove the orphan. Below is an excerpt of the corrected Markdown, with the `dining_room` section present and the orphan removed.

        @Code(name: "haunted.md", file: 04-haunted-fixed.txt)
      }
      @Step {
        Validate again. With these fixes applied, the report should be clean.

        @Code(name: "validator.txt", file: 04-validate-clean.txt)
      }
    }
  }

  @Section(title: "Compile the Story") {
    @ContentAndMedia {
      Compile the repaired source into a directory–based `.storybundle`. The compiler copies your `texts/`, writes a `manifest.json` that records a hash of the graph for integrity checks, and saves the graph into `graph.json`. Apps load bundles with `StoryBundleLoader`.
    }
    @Steps {
      @Step {
        Run the compiler and review the bundle structure. You can load this bundle at runtime with `StoryBundleLoader`.

        @Code(name: "compiler.txt", file: 05-compile-command.txt)
        @Code(name: "bundle structure", file: 05-bundle-tree.txt)
      }
    }
  }

  @Section(title: "Outcome") {
    @ContentAndMedia {
      You now have a validated Haunted House story and a compiled `.storybundle` that mirrors your source. This is the foundation for the next tutorial, where you’ll load the bundle, create a `StoryEngine`, and build a small CLI to read text and advance by choice. Each time you make changes to your story, run the validator again to ensure consistency and no unreachable areas.
    }
    @Steps {
      @Step { You're ready to move on to playing the story in Swift. }
    }
  }
}
