@Intro(title: "Playing a Story with StoryEngine") {
    In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a `StoryEngine`, print the current node’s prose, enumerate available choices, and call `select(choiceID:)` to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.

    StoryKit’s runtime model is deliberately small. Your application defines state by conforming to `StoryState` (at minimum, a `currentNode` of type `NodeID`). Predicates, effects, and actions live in registries that map string identifiers from your content to sendable closures in your app’s domain. The engine is an actor that owns the story and state; it filters choices through predicates, applies effects when moving between nodes, and (optionally) triggers autosave after transitions and actions. There is no `run()` method: the engine exposes current context and moves forward only when your code calls `select` with a specific choice id.

    The CLI runner you build here is intentionally simple: print text, present choices, read a line, and select. In the next tutorial you’ll enrich this with mechanics like skill checks, battles, and the final ritual action. For now, focus on the runtime plumbing—loading, printing, choosing—so the next layer has a clean place to land.
}

@Section(title: "Project Setup") {
    @ContentAndMedia {
        Create a new executable Swift package and add a dependency on StoryKit. During development, a path dependency is convenient if the package is adjacent to your StoryKit checkout; for teams, pin to a Git revision or a version tag. The sample `Package.swift` below uses a path dependency for local builds.
    }
    @Steps {
        @Step {
            Initialize a package and open it in your editor. Replace `Package.swift` and scaffold a minimal `main.swift`.

            @Code(name: "Package.swift (CLI)", file: 02-01-package.swift)
            @Code(name: "main.swift (stub)", file: 02-01-main-stub.swift)
        }
    }
}

@Section(title: "Command-Line Interface") {
    @ContentAndMedia {
        Use `swift-argument-parser` to define a simple command that accepts a positional path to a compiled `.storybundle`. A positional argument keeps the command easy to type and mirrors many Unix tools. You can expand this later with options or subcommands.

        See the ArgumentParser docs to learn more: https://github.com/apple/swift-argument-parser
    }
    @Steps {
        @Step {
            Create a command type with a single positional argument for the bundle path, then call into your `run()` implementation. This keeps the CLI’s entry point focused while the rest of the code handles loading and play.

            @Code(name: "Main.swift", file: 02-05-Main.swift)
        }
    }
}

@Section(title: "Define Minimal State") {
    @ContentAndMedia {
        Implement a tiny `HauntedState` conforming to `StoryState`. The engine only requires `currentNode`; everything else is up to your app. Why this design?

        - Purpose: StoryKit separates content (the graph) from mechanics (your rules). `StoryState` lives in your app so you can evolve mechanics without rewriting content.
        - What the client gains: You own the shape of state (health, sanity, inventory, flags) and control how it changes. Tests can construct state directly, and different apps can reuse the same story with different state models.
        - What StoryKit gains: A small, stable core focused on traversal and validation. The engine doesn’t need to know your game’s details to run safely and predictably.
    }
    @Steps {
        @Step {
            Add a single-file state definition. Keep it small; you’ll extend it later.

            @Code(name: "HauntedState.swift", file: 02-02-HauntedState.swift)
        }
    }
}

@Section(title: "Load the Story Bundle") {
    @ContentAndMedia {
        Use `StoryBundleLoader` to load a compiled bundle. A bundle contains `manifest.json`, `graph.json`, and a `texts/` directory; the loader decodes `graph.json` into a `Story` value.

        How loading and caching work together:
        - `StoryBundleLoader` performs a straightforward decode of the graph; it’s fast and keeps authoring files out of your runtime.
        - For prose, StoryKit provides text providers and actor‑based cached providers. They parse Markdown on demand and cache sections with LRU eviction, purging on memory pressure. This lets you trade a tiny amount of first‑read cost for excellent steady‑state performance.
        - Concurrency: cached providers are actors and integrate naturally with Swift Concurrency. Your app can call into the engine and providers without sharing mutable state across threads.
    }
    @Steps {
        @Step {
            Implement a helper that returns a `Story` for a bundle path. This keeps `main.swift` clean and makes testing straightforward.

            @Code(name: "LoadBundle.swift", file: 02-03-LoadBundle.swift)
        }
    }
}

@Section(title: "Create the Engine & Print Nodes") {
    @ContentAndMedia {
        Construct the engine with your `Story`, `HauntedState`, and (for now) empty predicate/effect/action registries. The engine starts at `story.start`; there is no explicit `run()`—you stay in control. The loop is built in small, understandable steps:

        1) Ask the engine for the current node. Keeping this explicit makes state easy to inspect and test.
        2) Render a clear header, the node’s text, and a list of choices. StoryKit separates prose (Markdown) from the graph, so you choose how to present text.
        3) Read a line from stdin and map it to a choice. This keeps I/O concerns out of the engine.
        4) Advance the engine by calling `select(choiceID:)`. Behind the scenes, the engine evaluates predicates, applies effects, moves to the destination, and (optionally) triggers autosave.

        Reading from stdin is enough for a first pass. Production apps replace stdin with UI, but the control flow remains: render, choose, advance.
    }
    @Steps {
        @Step {
            Implement the loop in steps.

            1) Header: print `=== <node id> ===` to ground the reader.
            2) Node text: use `BundleTextProvider` to fetch the Markdown section for the node’s `TextRef`.
            3) Choices: list the available choices with 1‑based indices and their `id`s.

            @Code(name: "EngineLoop.swift", file: 02-04-EngineLoop.swift)
        }
        @Step {
            Advance the engine. Read an index, look up the selected choice, and call `select(choiceID:)`. The engine evaluates predicates, applies effects, transitions to the destination, applies destination on‑enter effects, and then returns control to you for the next render.

            @Code(name: "EngineLoop.swift", file: 02-04-EngineLoop.swift)
        }
    }
}

@Section(title: "Outcome") {
    @ContentAndMedia {
        You now have a small but capable CLI that can load and play a StoryKit bundle. Here’s what you built:

        - Your work:
          - A command‑line interface using ArgumentParser with a positional bundle path.
          - A minimal `StoryState` and a loop that prints headers, text, and choices.
          - A selection flow that advances the engine cleanly.

        - StoryKit’s contributions (for free):
          - Safe concurrency via actors for the engine and cached text providers.
          - Markdown parsing and caching with LRU eviction and memory‑pressure purging.
          - A compact engine API that evaluates predicates, applies effects, handles on‑enter hooks, and supports autosave.
          - A consistent file format and a loader that keeps authoring files out of your runtime.

        Next, you’ll layer in the mechanics that make stories feel interactive and reactive: predicates for gating choices, effects for state changes, and actions for richer encounters. StoryKit provides the scaffolding so you can focus on rules and prose—not plumbing.
    }
}
