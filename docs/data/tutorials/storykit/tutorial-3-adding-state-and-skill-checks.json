{"sections":[{"content":[{"inlineContent":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"StoryKit is deliberately agnostic to any specific game engine. It focuses on node‑to‑node flow and flexible metadata, while leaving rules and systems to your app. Because mechanics live in your client, the same story can drive very different experiences—your rules decide what “has‑item”, “lose‑sanity”, or “ritual” mean. Content stays declarative and portable; you can validate and iterate without recompiling your app."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"By the end, your CLI will present checks with narrative feedback, support short fights with a chance to flee, and enforce a ritual’s required items and order. You’ll also wire autosave so progress survives between rounds and after risky choices."}],"type":"paragraph"}],"kind":"hero","estimatedTimeInMinutes":60,"title":"Checks, Effects, Actions, Battles, and the Ritual","chapter":"Checks, Effects, Actions, Battles, and the Ritual"},{"tasks":[{"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Treat your ","type":"text"},{"code":"StoryState","type":"codeVoice"},{"text":" like a character sheet. It’s the single source of truth for stats (health, sanity), inventory (item ids), and flags. Keeping this in your app means you can evolve mechanics freely while the story stays declarative and portable. It’s also what lets StoryKit be engine‑agnostic: it handles node flow and metadata, and your client supplies the rules.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"We’ll build it up in small steps so each addition is obvious and testable.","type":"text"}]}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"anchor":"Designing-Game-State","stepsSection":[{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Start with a minimal state that only satisfies the engine: a ","type":"text"},{"code":"currentNode","type":"codeVoice"},{"text":".","type":"text"}]}],"code":"03-01a-HauntedState-Struct.swift","runtimePreview":null,"caption":[],"media":null},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Add fields you’ll use throughout the story: ","type":"text"},{"code":"health","type":"codeVoice"},{"text":", ","type":"text"},{"code":"sanity","type":"codeVoice"},{"text":", ","type":"text"},{"code":"inventory","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"flags","type":"codeVoice"},{"text":".","type":"text"}]}],"code":"03-01b-HauntedState-Fields.swift","runtimePreview":null,"caption":[],"media":null},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Add tiny helpers so updates are safe and readable: ","type":"text"},{"code":"gain(_:)","type":"codeVoice"},{"text":", ","type":"text"},{"code":"has(_:)","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"setFlag(_:to:)","type":"codeVoice"},{"text":".","type":"text"}]}],"code":"03-01c-HauntedState-Helpers.swift","runtimePreview":null,"caption":[],"media":null}],"title":"Designing Game State"},{"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Roll‑under checks fit horror because success is often narrow and failure meaningful. We’ll add a tiny dice helper, then register two useful predicates. Predicates are pure: they read state and parameters and return a Bool.","type":"text"}]}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"anchor":"Roll-Under-Checks-Predicates","stepsSection":[{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Add a ","type":"text"},{"code":"rollD20()","type":"codeVoice"},{"text":" and a ","type":"text"},{"code":"checkUnder(_:)","type":"codeVoice"},{"text":" helper to support roll‑under checks.","type":"text"}]}],"code":"03-02a-Dice.swift","runtimePreview":null,"caption":[],"media":null},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Register a ","type":"text"},{"code":"has-item","type":"codeVoice"},{"text":" predicate that maps directly to your inventory semantics.","type":"text"}]}],"code":"03-02b-Register-HasItem.swift","runtimePreview":null,"caption":[],"media":null},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Register a ","type":"text"},{"code":"stat-at-least","type":"codeVoice"},{"text":" predicate that compares a stat to a threshold provided in parameters.","type":"text"}]}],"code":"03-02c-Register-StatAtLeast.swift","runtimePreview":null,"caption":[],"media":null}],"title":"Roll-Under Checks & Predicates"},{"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Effects are deterministic state changes invoked on selection or on‑enter. Keep them small and composable, and map string parameters to integers and booleans carefully. This is where narrative consequences become concrete: a sanity drop, an injury, an inventory gain, a flag that opens later branches.","type":"text"}]}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"anchor":"Effects-Damage-Sanity-Items-Flags","stepsSection":[{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Register a ","type":"text"},{"code":"lose-sanity","type":"codeVoice"},{"text":" effect. Clamp values to safe ranges so state never goes out of bounds.","type":"text"}]}],"code":"03-03a-Register-LoseSanity.swift","runtimePreview":null,"caption":[],"media":null},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Register a ","type":"text"},{"code":"take-damage","type":"codeVoice"},{"text":" effect. Again, clamp to keep state valid.","type":"text"}]}],"caption":[],"code":"03-03b-Register-TakeDamage.swift","runtimePreview":null,"media":null},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Register a ","type":"text"},{"code":"gain-item","type":"codeVoice"},{"text":" effect. Treat inventory additions as idempotent.","type":"text"}]}],"caption":[],"code":"03-03c-Register-GainItem.swift","runtimePreview":null,"media":null},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Register a ","type":"text"},{"code":"set-flag","type":"codeVoice"},{"text":" effect. Flags open later branches.","type":"text"}]}],"caption":[],"code":"03-03d-Register-SetFlag.swift","runtimePreview":null,"media":null}],"title":"Effects: Damage, Sanity, Items, Flags"},{"anchor":"Entities-Multi-Round-Battles-with-Flee","title":"Entities & Multi-Round Battles with Flee","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"inlineContent":[{"type":"text","text":"Encounters benefit from pacing. A melee round should produce narration, potentially modify state (damage to player or enemy), and offer a flee option keyed to a check. Model opponents minimally—hp, attack range, name—and drive the action through an "},{"code":"ActionRegistry","type":"codeVoice"},{"type":"text","text":" closure. Return "},{"code":".requiresUserInput","type":"codeVoice"},{"type":"text","text":" when the fight continues; return "},{"code":".completed","type":"codeVoice"},{"type":"text","text":" when it ends."}],"type":"paragraph"}]}],"stepsSection":[{"code":"03-04a-EntityModel.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Define a tiny entity model (hp, attack range, name). Keep it small on purpose."}],"type":"paragraph"}],"caption":[]},{"code":"03-04b-Action-MeleeRound.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Register a "},{"code":"melee-round","type":"codeVoice"},{"type":"text","text":" action that advances the fight and narrates a round, including hits\/misses and retaliation."}],"type":"paragraph"}],"caption":[]},{"code":"03-04c-Flee-Logic.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Add flee support using a roll‑under check. Return "},{"code":".completed","type":"codeVoice"},{"type":"text","text":" when the player escapes."}],"type":"paragraph"}],"caption":[]}]},{"anchor":"The-Final-Ritual-Ordered-Sequence","title":"The Final Ritual (Ordered Sequence)","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"inlineContent":[{"type":"text","text":"The ritual requires multiple items and a strict order. Author the action as a single "},{"code":"ritual","type":"codeVoice"},{"type":"text","text":" id that accepts an "},{"code":"order","type":"codeVoice"},{"type":"text","text":" parameter (comma‑joined steps). In code, verify inventory and order; set flags to route to outcomes. This keeps branching logic out of the story graph while preserving authoring clarity."}],"type":"paragraph"}]}],"stepsSection":[{"code":"03-05a-Action-Ritual-Signature.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Declare the ritual action signature and parse the "},{"code":"order","type":"codeVoice"},{"type":"text","text":" parameter."}],"type":"paragraph"}],"caption":[]},{"code":"03-05b-Action-Ritual-Checks.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Verify required items and validate the item order (candle → tome → dagger)."}],"type":"paragraph"}],"caption":[]},{"code":"03-05c-Action-Ritual-Outcomes.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Toggle outcome flags to route success\/failure branches cleanly."}],"type":"paragraph"}],"caption":[]}]},{"anchor":"Autosave-Between-Rounds","title":"Autosave Between Rounds","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"inlineContent":[{"type":"text","text":"Long encounters and risky sequences should persist. Use "},{"code":"JSONFileSaveProvider","type":"codeVoice"},{"type":"text","text":" with "},{"code":"makeAutoSaveHandler","type":"codeVoice"},{"type":"text","text":" to write a snapshot after transitions and actions. The engine’s "},{"code":"autosave","type":"codeVoice"},{"type":"text","text":" closure is invoked after successful "},{"code":"select","type":"codeVoice"},{"type":"text","text":" and "},{"code":"performAction","type":"codeVoice"},{"type":"text","text":" calls."}],"type":"paragraph"}]}],"stepsSection":[{"code":"03-06a-AutoSave-Factory.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Create a small factory for an autosave closure keyed by a story id and slot name."}],"type":"paragraph"}],"caption":[]},{"code":"03-06b-Engine-Init-AutoSave.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Pass the closure to "},{"code":"StoryEngine","type":"codeVoice"},{"type":"text","text":" as "},{"code":"autosave:","type":"codeVoice"},{"type":"text","text":" when you construct the engine."}],"type":"paragraph"}],"caption":[]}]},{"anchor":"Outcome","title":"Outcome","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"inlineContent":[{"type":"text","text":"Your CLI now supports checks, registered predicates\/effects, a multi‑round melee action with flee, the ordered ritual, and autosave. Mechanics stay in your client while content stays declarative and portable; StoryKit remains agnostic to the game engine and focused on node flow and metadata."}],"type":"paragraph"}]}],"stepsSection":[{"code":null,"runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"You can now enrich narration, route results to specialized nodes, or transition via "},{"code":"performGlobalAction","type":"codeVoice"},{"type":"text","text":" to endings—without changing the story’s structure. Next up, you can refine rules, make checks probabilistic or stat‑driven, and expand encounters, all while StoryKit continues to handle traversal, loading, and validation."}],"type":"paragraph"}],"caption":[]}]}],"kind":"tasks"}],"schemaVersion":{"patch":0,"minor":3,"major":0},"identifier":{"url":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks"]}],"kind":"project","hierarchy":{"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents","paths":[["doc:\/\/StoryKit\/tutorials\/table-of-contents","doc:\/\/StoryKit\/tutorials\/table-of-contents\/$volume","doc:\/\/StoryKit\/tutorials\/table-of-contents\/Checks,-Effects,-Actions,-Battles,-and-the-Ritual"]],"modules":[{"projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story","sections":[{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Validating-a-Story"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Story-Node-Structure"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Text-Content"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Compile-the-Story"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Outcome"}]}],"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Building-and-Validating-a-Story"},{"projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift","sections":[{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Outcome"}]}],"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Playing-a-Story-with-StoryEngine"},{"projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","sections":[{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Entities-Multi-Round-Battles-with-Flee"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Ordered-Sequence"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Outcome"}]}],"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Checks,-Effects,-Actions,-Battles,-and-the-Ritual"}]},"metadata":{"categoryPathComponent":"table-of-contents","category":"StoryKit","role":"project","title":"Checks, Effects, Actions, Battles, and the Ritual"},"references":{"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift","title":"Playing a Story with StoryEngine","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift","estimatedTime":"35min","role":"project","kind":"project","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Entities-Multi-Round-Battles-with-Flee":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Entities-Multi-Round-Battles-with-Flee","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Entities-Multi-Round-Battles-with-Flee","title":"Entities & Multi-Round Battles with Flee","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Text-Content":{"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Text-Content","type":"section","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Text-Content","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}],"title":"Text Content","kind":"section","role":"pseudoSymbol"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds","title":"Autosave Between Rounds","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Autosave-Between-Rounds","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}]},"03-02a-Dice.swift":{"syntax":"","type":"file","highlights":[],"content":["import Foundation","","public func rollD20() -> Int { Int.random(in: 1...20) }","public func checkUnder(_ threshold: Int, roll: Int = rollD20()) -> Bool { roll <= threshold }",""],"fileName":"Dice & check helpers","identifier":"03-02a-Dice.swift","fileType":""},"03-04b-Action-MeleeRound.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func registerMeleeRound(into acts: inout ActionRegistry<HauntedState>) {","    acts.register(\"melee-round\") { state, params in","        \/\/ Narratively: attempt a hit against an enemy; enemy may retaliate.","        \/\/ This sample hints at mechanics; a real version tracks enemy hp in state.","        let hit = rollD20() > 10","        if hit {","            \/\/ e.g., set a flag for narration","            state.setFlag(\"lastHit\", to: true)","        } else {","            \/\/ retaliation knocks sanity a bit","            state.sanity = max(0, state.sanity - 1)","        }","        return .requiresUserInput","    }","}",""],"fileName":"Action: melee-round","identifier":"03-04b-Action-MeleeRound.swift","fileType":""},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Story-Node-Structure":{"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Story-Node-Structure","type":"section","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Story-Node-Structure","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}],"title":"Story Node Structure","kind":"section","role":"pseudoSymbol"},"03-03d-Register-SetFlag.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func registerSetFlag(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"set-flag\") { state, params in","        guard let id = params[\"id\"], let val = params[\"value\"] else { return }","        if (val as NSString).boolValue { state.flags.insert(id) } else { state.flags.remove(id) }","    }","}",""],"fileName":"Effect: set-flag","identifier":"03-03d-Register-SetFlag.swift","fileType":""},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface":{"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface","type":"section","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Command-Line-Interface","abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"code":"StoryEngine","type":"codeVoice"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"code":"select(choiceID:)","type":"codeVoice"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}],"title":"Command-Line Interface","kind":"section","role":"pseudoSymbol"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Effects-Damage-Sanity-Items-Flags","title":"Effects: Damage, Sanity, Items, Flags","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}]},"doc://StoryKit/tutorials/table-of-contents":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents","url":"\/tutorials\/table-of-contents","title":"Meet StoryKit","role":"overview","kind":"overview","abstract":[{"type":"text","text":"StoryKit is a data‑driven engine and toolset for building branching, text‑forward experiences. These tutorials guide you from validating a story, to playing it with a small Swift app, to layering mechanics like checks, effects, and actions."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Roll-Under-Checks-Predicates","title":"Roll-Under Checks & Predicates","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State","title":"Define Minimal State","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Define-Minimal-State","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Project-Setup","title":"Project Setup","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"code":"StoryEngine","type":"codeVoice"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"code":"select(choiceID:)","type":"codeVoice"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}]},"doc://StoryKit/tutorials/table-of-contents/Checks,-Effects,-Actions,-Battles,-and-the-Ritual":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Checks,-Effects,-Actions,-Battles,-and-the-Ritual","title":"Checks, Effects, Actions, Battles, and the Ritual","url":"\/tutorials\/table-of-contents\/checks,-effects,-actions,-battles,-and-the-ritual","role":"article","kind":"article","abstract":[]},"03-04c-Flee-Logic.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func addFleeSupport(into acts: inout ActionRegistry<HauntedState>) {","    acts.register(\"flee\") { state, params in","        let dex = Int(params[\"dex\"] ?? \"10\") ?? 10","        if checkUnder(dex) {","            state.setFlag(\"fledCombat\", to: true)","            return .completed","        }","        return .requiresUserInput","    }","}",""],"fileName":"Flee logic","identifier":"03-04c-Flee-Logic.swift","fileType":""},"03-03b-Register-TakeDamage.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func registerTakeDamage(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"take-damage\") { state, params in","        let amt = Int(params[\"by\"] ?? \"1\") ?? 1","        state.health = max(0, state.health - amt)","    }","}",""],"fileName":"Effect: take-damage","identifier":"03-03b-Register-TakeDamage.swift","fileType":""},"03-05a-Action-Ritual-Signature.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func registerRitual(into acts: inout ActionRegistry<HauntedState>) {","    acts.register(\"ritual\") { state, params in","        let order = (params[\"order\"] ?? \"\").split(separator: \",\").map { $0.trimmingCharacters(in: .whitespaces) }","        \/\/ More logic in later steps…","        return .requiresUserInput","    }","}",""],"fileName":"Ritual (signature)","identifier":"03-05a-Action-Ritual-Signature.swift","fileType":""},"03-06a-AutoSave-Factory.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func makeAutoSave(storyID: String) -> @Sendable (HauntedState) async throws -> Void {","    let provider = JSONFileSaveProvider(directory: URL(fileURLWithPath: NSTemporaryDirectory()))","    return makeAutoSaveHandler(storyID: storyID, provider: provider)","}",""],"fileName":"Autosave (factory)","identifier":"03-06a-AutoSave-Factory.swift","fileType":""},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Compile-the-Story":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Compile-the-Story","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Compile-the-Story","title":"Compile the Story","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Outcome":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Outcome","title":"Outcome","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Outcome","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}]},"03-02c-Register-StatAtLeast.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func addStatAtLeast(to preds: inout PredicateRegistry<HauntedState>) {","    preds.register(\"stat-at-least\") { state, params in","        guard let key = params[\"stat\"], let minStr = params[\"min\"], let min = Int(minStr) else { return false }","        switch key {","        case \"health\": return state.health >= min","        case \"sanity\": return state.sanity >= min","        default: return false","        }","    }","}",""],"fileName":"Predicate: stat-at-least","identifier":"03-02c-Register-StatAtLeast.swift","fileType":""},"03-01a-HauntedState-Struct.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public init(start: NodeID) { self.currentNode = start }","}",""],"fileName":"State (minimal)","identifier":"03-01a-HauntedState-Struct.swift","fileType":""},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Outcome":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Outcome","title":"Outcome","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Outcome","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},"03-02b-Register-HasItem.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func makePredicates() -> PredicateRegistry<HauntedState> {","    var preds = PredicateRegistry<HauntedState>()","    preds.register(\"has-item\") { state, params in","        guard let id = params[\"item\"] else { return false }","        return state.inventory.contains(id)","    }","    return preds","}",""],"fileName":"Predicate: has-item","identifier":"03-02b-Register-HasItem.swift","fileType":""},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story","title":"Building and Validating a Story","estimatedTime":"30min","role":"project","kind":"project","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Ordered-Sequence":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Ordered-Sequence","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#The-Final-Ritual-Ordered-Sequence","title":"The Final Ritual (Ordered Sequence)","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes","title":"Create the Engine & Print Nodes","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Create-the-Engine-Print-Nodes","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#StoryKit-File-Formats","title":"StoryKit File Formats","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}]},"03-03c-Register-GainItem.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func registerGainItem(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"gain-item\") { state, params in","        if let id = params[\"item\"] { state.inventory.insert(id) }","    }","}",""],"fileName":"Effect: gain-item","identifier":"03-03c-Register-GainItem.swift","fileType":""},"03-05c-Action-Ritual-Outcomes.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func ritualOutcome(into acts: inout ActionRegistry<HauntedState>) {","    acts.register(\"ritual\") { state, params in","        let order = (params[\"order\"] ?? \"\").split(separator: \",\").map { $0.trimmingCharacters(in: .whitespaces) }","        if ritualChecks(state, order: order) {","            state.setFlag(\"ritual_success\", to: true)","            return .completed","        } else {","            state.setFlag(\"ritual_failed\", to: true)","            return .completed","        }","    }","}",""],"fileName":"Ritual (outcomes)","identifier":"03-05c-Action-Ritual-Outcomes.swift","fileType":""},"doc://StoryKit/tutorials/table-of-contents/Building-and-Validating-a-Story":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Building-and-Validating-a-Story","url":"\/tutorials\/table-of-contents\/building-and-validating-a-story","title":"Building and Validating a Story","role":"article","kind":"article","abstract":[]},"03-06b-Engine-Init-AutoSave.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","func makeEngine(story: Story) -> StoryEngine<HauntedState> {","    var preds = PredicateRegistry<HauntedState>()","    var effs = EffectRegistry<HauntedState>()","    var acts = ActionRegistry<HauntedState>()","    let autosave = try? makeAutoSave(storyID: story.metadata.id)","    return StoryEngine(","        story: story,","        initialState: HauntedState(start: story.start),","        predicateRegistry: preds,","        effectRegistry: effs,","        actionRegistry: acts,","        autosave: autosave","    )","}",""],"fileName":"Autosave (engine init)","identifier":"03-06b-Engine-Init-AutoSave.swift","fileType":""},"03-03a-Register-LoseSanity.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func registerLoseSanity(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"lose-sanity\") { state, params in","        let amt = Int(params[\"by\"] ?? \"1\") ?? 1","        state.sanity = max(0, state.sanity - amt)","    }","}",""],"fileName":"Effect: lose-sanity","identifier":"03-03a-Register-LoseSanity.swift","fileType":""},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Outcome":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Outcome","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Outcome","title":"Outcome","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Validating-a-Story":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Validating-a-Story","title":"Validating a Story","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Validating-a-Story","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks":{"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","type":"topic","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks","abstract":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}],"title":"Checks, Effects, Actions, Battles, and the Ritual","kind":"project","role":"project","estimatedTime":"1hr 0min"},"03-01b-HauntedState-Fields.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public var health: Int = 10","    public var sanity: Int = 10","    public var inventory: Set<String> = []","    public var flags: Set<String> = []","    public init(start: NodeID) { self.currentNode = start }","}",""],"fileName":"State (fields)","identifier":"03-01b-HauntedState-Fields.swift","fileType":""},"doc://StoryKit/tutorials/table-of-contents/Playing-a-Story-with-StoryEngine":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Playing-a-Story-with-StoryEngine","title":"Playing a Story with StoryEngine","url":"\/tutorials\/table-of-contents\/playing-a-story-with-storyengine","role":"article","kind":"article","abstract":[]},"03-04a-EntityModel.swift":{"syntax":"","type":"file","highlights":[],"content":["public struct Enemy {","    public var name: String","    public var hp: Int","    public var attack: ClosedRange<Int>","}",""],"fileName":"Entity model","identifier":"03-04a-EntityModel.swift","fileType":""},"03-01c-HauntedState-Helpers.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public var health: Int = 10","    public var sanity: Int = 10","    public var inventory: Set<String> = []","    public var flags: Set<String> = []","    public init(start: NodeID) { self.currentNode = start }","","    public mutating func gain(_ item: String) { inventory.insert(item) }","    public func has(_ item: String) -> Bool { inventory.contains(item) }","    public mutating func setFlag(_ id: String, to value: Bool) {","        if value { flags.insert(id) } else { flags.remove(id) }","    }","}",""],"fileName":"State (helpers)","identifier":"03-01c-HauntedState-Helpers.swift","fileType":""},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State","title":"Designing Game State","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Designing-Game-State","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle","title":"Load the Story Bundle","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Load-the-Story-Bundle","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},"03-05b-Action-Ritual-Checks.swift":{"syntax":"","type":"file","highlights":[],"content":["import StoryKit","","public func ritualChecks(_ state: HauntedState, order: [String]) -> Bool {","    let required = [\"candle\", \"tome\", \"dagger\"]","    guard state.has(\"black_candle\"), state.has(\"forbidden_tome\"), state.has(\"silver_dagger\") else { return false }","    return order.map { $0.lowercased() } == required","}",""],"fileName":"Ritual (checks)","identifier":"03-05b-Action-Ritual-Checks.swift","fileType":""}}}