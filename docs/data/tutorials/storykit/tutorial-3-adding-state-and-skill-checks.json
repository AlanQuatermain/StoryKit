{"sections":[{"kind":"hero","content":[{"inlineContent":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"StoryKit is deliberately agnostic to any specific game engine. It focuses on node‑to‑node flow and flexible metadata, while leaving rules and systems to your app. Because mechanics live in your client, the same story can drive very different experiences—your rules decide what “has‑item”, “lose‑sanity”, or “ritual” mean. Content stays declarative and portable; you can validate and iterate without recompiling your app.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"By the end, your CLI will present checks with narrative feedback, support short fights with a chance to flee, and enforce a ritual’s required items and order. You’ll also wire autosave so progress survives between rounds and after risky choices."}],"type":"paragraph"}],"estimatedTimeInMinutes":60,"title":"Checks, Effects, Actions, Battles, and the Ritual","chapter":"Checks, Effects, Actions, Battles, and the Ritual"},{"kind":"tasks","tasks":[{"title":"Designing Game State","contentSection":[{"kind":"contentAndMedia","content":[{"inlineContent":[{"text":"Treat your ","type":"text"},{"code":"StoryState","type":"codeVoice"},{"text":" like a character sheet. It’s the single source of truth for stats (health, sanity), inventory (item ids), and flags. Keeping this in your app means you can evolve mechanics freely while the story stays declarative and portable. It’s also what lets StoryKit be engine‑agnostic: it handles node flow and metadata, and your client supplies the rules.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We’ll build it up in small steps so each addition is obvious and testable, then demonstrate advanced patterns with custom structures for complex mechanics."}],"type":"paragraph"}],"mediaPosition":"trailing"}],"anchor":"Designing-Game-State","stepsSection":[{"media":null,"code":"HauntedState.swift","runtimePreview":null,"caption":[],"content":[{"inlineContent":[{"type":"text","text":"Start with a minimal state that only satisfies the engine: a "},{"code":"currentNode","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"step"},{"media":null,"code":"HauntedState@2.swift","runtimePreview":null,"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add fields you’ll use throughout the story: "},{"code":"health","type":"codeVoice"},{"type":"text","text":", "},{"code":"sanity","type":"codeVoice"},{"type":"text","text":", "},{"code":"inventory","type":"codeVoice"},{"type":"text","text":", and "},{"code":"flags","type":"codeVoice"},{"type":"text","text":"."}]}],"type":"step"},{"type":"step","caption":[],"content":[{"inlineContent":[{"text":"Add tiny helpers so updates are safe and readable: ","type":"text"},{"code":"gain(_:)","type":"codeVoice"},{"text":", ","type":"text"},{"code":"has(_:)","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"setFlag(_:to:)","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}],"code":"HauntedState@3.swift","media":null,"runtimePreview":null},{"type":"step","caption":[],"content":[{"inlineContent":[{"text":"For complex mechanics, create dedicated structures. Add a ","type":"text"},{"code":"Ritual","type":"codeVoice"},{"text":" struct to track multi‑step sequences properly.","type":"text"}],"type":"paragraph"}],"code":"HauntedState@4.swift","media":null,"runtimePreview":null},{"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add a "},{"type":"codeVoice","code":"BoneServant"},{"type":"text","text":" struct for chase mechanics, demonstrating how structured state management scales to advanced game systems."}]}],"code":"HauntedState@5.swift","media":null,"runtimePreview":null},{"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Add methods to the ","type":"text"},{"type":"codeVoice","code":"Ritual"},{"text":" struct to encapsulate the logic for each ritual step with proper validation.","type":"text"}]}],"code":"HauntedState@6.swift","media":null,"runtimePreview":null},{"type":"step","caption":[],"content":[{"inlineContent":[{"type":"text","text":"Complete the "},{"type":"codeVoice","code":"Ritual"},{"type":"text","text":" methods to support the full three‑step sequence: candle, tome, sacrifice."}],"type":"paragraph"}],"code":"HauntedState@7.swift","media":null,"runtimePreview":null},{"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Finalize the state design with the complete "},{"code":"Ritual","type":"codeVoice"},{"text":" struct including the final sacrifice method that activates the bone servant.","type":"text"}]}],"code":"HauntedState@8.swift","media":null,"runtimePreview":null}]},{"title":"Roll-Under Checks & Predicates","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"text":"Roll‑under checks fit horror because success is often narrow and failure meaningful. We’ll add a tiny dice helper, then register two useful predicates. Predicates are pure: they read state and parameters and return a Bool.","type":"text"}]}],"mediaPosition":"trailing"}],"anchor":"Roll-Under-Checks-Predicates","stepsSection":[{"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Add a ","type":"text"},{"code":"rollD20()","type":"codeVoice"},{"text":" and a ","type":"text"},{"code":"checkUnder(_:)","type":"codeVoice"},{"text":" helper to support roll‑under checks.","type":"text"}]}],"media":null,"runtimePreview":null,"code":"Predicates.swift"},{"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a "},{"type":"codeVoice","code":"has-item"},{"type":"text","text":" predicate that maps directly to your inventory semantics."}]}],"media":null,"runtimePreview":null,"code":"Predicates@2.swift"},{"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a "},{"code":"stat-at-least","type":"codeVoice"},{"type":"text","text":" predicate that compares a stat to a threshold provided in parameters."}]}],"media":null,"runtimePreview":null,"code":"Predicates@3.swift"}]},{"anchor":"Effects-Damage-Sanity-Items-Flags","title":"Effects: Damage, Sanity, Items, Flags","contentSection":[{"kind":"contentAndMedia","content":[{"inlineContent":[{"text":"Effects are deterministic state changes invoked on selection or on‑enter. Keep them small and composable, and map string parameters to integers and booleans carefully. This is where narrative consequences become concrete: a sanity drop, an injury, an inventory gain, a flag that opens later branches.","type":"text"}],"type":"paragraph"}],"mediaPosition":"trailing"}],"stepsSection":[{"caption":[],"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a "},{"code":"lose-sanity","type":"codeVoice"},{"type":"text","text":" effect. Clamp values to safe ranges so state never goes out of bounds."}]}],"type":"step","code":"Effects.swift","runtimePreview":null},{"caption":[],"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a "},{"type":"codeVoice","code":"take-damage"},{"type":"text","text":" effect. Again, clamp to keep state valid."}]}],"type":"step","code":"Effects@2.swift","runtimePreview":null},{"caption":[],"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a "},{"code":"gain-item","type":"codeVoice"},{"type":"text","text":" effect. Treat inventory additions as idempotent."}]}],"type":"step","code":"Effects@3.swift","runtimePreview":null},{"type":"step","caption":[],"media":null,"code":"Effects@4.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Register a ","type":"text"},{"type":"codeVoice","code":"set-flag"},{"text":" effect. Flags open later branches.","type":"text"}]}]}]},{"anchor":"Chase-Mechanics-Bone-Servant-Encounters","title":"Chase Mechanics & Bone Servant Encounters","contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"inlineContent":[{"text":"Advanced encounters benefit from structured mechanics. The bone servant represents a persistent threat that tracks the player through multiple rooms. Model this using dedicated structures and actions that work with those structures through extensions.","type":"text"}],"type":"paragraph"}]}],"stepsSection":[{"caption":[],"code":"Battle.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Create an extension to organize bone servant actions. Start with the basic structure.","type":"text"}]}],"type":"step","media":null},{"caption":[],"code":"Battle@2.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a "},{"code":"check_pursuit","type":"codeVoice"},{"type":"text","text":" action that advances the chase and checks if the bone servant has arrived."}]}],"type":"step","media":null},{"caption":[],"code":"Battle@3.swift","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Add flee support for escaping the bone servant using a dexterity check. Reset the servant on successful escape."}],"type":"paragraph"}],"type":"step","media":null}]},{"anchor":"The-Final-Ritual-Individual-Actions","title":"The Final Ritual (Individual Actions)","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"inlineContent":[{"text":"The ritual requires multiple items and a strict sequence of individual actions. Rather than a single action with ordering parameters, implement each step as its own action that works with the ","type":"text"},{"code":"Ritual","type":"codeVoice"},{"text":" struct methods. This provides clearer narrative control and better user experience.","type":"text"}],"type":"paragraph"}]}],"stepsSection":[{"caption":[],"code":"Ritual.swift","runtimePreview":null,"media":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create an extension to organize ritual actions. Start with the basic structure."}]}]},{"caption":[],"code":"Ritual@2.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Register the "},{"code":"light_candle","type":"codeVoice"},{"type":"text","text":" action that validates inventory and calls the appropriate "},{"type":"codeVoice","code":"Ritual"},{"type":"text","text":" method."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add the "},{"type":"codeVoice","code":"read_tome"},{"type":"text","text":" action that enforces the proper sequence through the "},{"type":"codeVoice","code":"Ritual"},{"type":"text","text":" struct’s logic."}]}],"caption":[],"media":null,"type":"step","runtimePreview":null,"code":"Ritual@3.swift"},{"content":[{"inlineContent":[{"type":"text","text":"Complete the ritual with "},{"type":"codeVoice","code":"make_sacrifice"},{"type":"text","text":" action that activates the bone servant on successful completion."}],"type":"paragraph"}],"caption":[],"media":null,"type":"step","runtimePreview":null,"code":"Ritual@4.swift"}]},{"anchor":"Autosave-Between-Rounds","title":"Autosave Between Rounds","stepsSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Create a small factory for an autosave closure keyed by a story id and slot name.","type":"text"}]}],"caption":[],"code":"AutoSave.swift","runtimePreview":null,"media":null,"type":"step"},{"caption":[],"code":"AutoSave@2.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"text":"Pass the closure to ","type":"text"},{"type":"codeVoice","code":"StoryEngine"},{"text":" as ","type":"text"},{"type":"codeVoice","code":"autosave:"},{"text":" when you construct the engine.","type":"text"}],"type":"paragraph"}]}],"contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"inlineContent":[{"type":"text","text":"Long encounters and risky sequences should persist. Use "},{"type":"codeVoice","code":"JSONFileSaveProvider"},{"type":"text","text":" with "},{"type":"codeVoice","code":"makeAutoSaveHandler"},{"type":"text","text":" to write a snapshot after transitions and actions. The engine’s "},{"type":"codeVoice","code":"autosave"},{"type":"text","text":" closure is invoked after successful "},{"type":"codeVoice","code":"select"},{"type":"text","text":" and "},{"type":"codeVoice","code":"performAction"},{"type":"text","text":" calls."}],"type":"paragraph"}]}]},{"stepsSection":[{"caption":[],"type":"step","content":[{"inlineContent":[{"type":"text","text":"You can now enrich narration, route results to specialized nodes, or transition via "},{"type":"codeVoice","code":"performGlobalAction"},{"type":"text","text":" to endings—without changing the story’s structure. Next up, you can refine rules, make checks probabilistic or stat‑driven, and expand encounters, all while StoryKit continues to handle traversal, loading, and validation."}],"type":"paragraph"}],"media":null,"code":null,"runtimePreview":null}],"contentSection":[{"mediaPosition":"trailing","content":[{"inlineContent":[{"type":"text","text":"Your CLI now supports checks, registered predicates\/effects, a multi‑round melee action with flee, the ordered ritual, and autosave. Mechanics stay in your client while content stays declarative and portable; StoryKit remains agnostic to the game engine and focused on node flow and metadata."}],"type":"paragraph"}],"kind":"contentAndMedia"}],"title":"Outcome","anchor":"Outcome"}]}],"kind":"project","hierarchy":{"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents","paths":[["doc:\/\/StoryKit\/tutorials\/table-of-contents","doc:\/\/StoryKit\/tutorials\/table-of-contents\/$volume","doc:\/\/StoryKit\/tutorials\/table-of-contents\/Checks,-Effects,-Actions,-Battles,-and-the-Ritual"]],"modules":[{"projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story","sections":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Validating-a-Story","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Story-Node-Structure","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Text-Content","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Compile-the-Story","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Outcome","kind":"task"}]}],"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Building-and-Validating-a-Story"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Outcome"}],"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift"}],"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Playing-a-Story-with-StoryEngine"},{"projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","sections":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates","kind":"task"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Chase-Mechanics-Bone-Servant-Encounters"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Individual-Actions"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Outcome"}]}],"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Checks,-Effects,-Actions,-Battles,-and-the-Ritual"}]},"metadata":{"title":"Checks, Effects, Actions, Battles, and the Ritual","role":"project","category":"StoryKit","categoryPathComponent":"table-of-contents"},"identifier":{"url":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","interfaceLanguage":"swift"},"variants":[{"paths":["\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"references":{"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Outcome":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Outcome","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Outcome","title":"Outcome","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds":{"abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds","kind":"section","title":"Autosave Between Rounds","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Autosave-Between-Rounds"},"HauntedState@3.swift":{"type":"file","fileType":"swift","highlights":[{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15}],"fileName":"HauntedState.swift","syntax":"swift","identifier":"HauntedState@3.swift","content":["import StoryKit","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public var health: Int = 10","    public var sanity: Int = 10","    public var inventory: Set<String> = []","    public var flags: Set<String> = []","    public init(start: NodeID) { self.currentNode = start }","","    public mutating func gain(_ item: String) { inventory.insert(item) }","    public func has(_ item: String) -> Bool { inventory.contains(item) }","    public mutating func setFlag(_ id: String, to value: Bool) {","        if value { flags.insert(id) } else { flags.remove(id) }","    }","}"]},"Ritual@3.swift":{"fileName":"Ritual.swift","fileType":"swift","syntax":"swift","identifier":"Ritual@3.swift","content":["import StoryKit","","extension Ritual {","    static func registerActions(into acts: inout ActionRegistry<HauntedState>) {","        acts.register(\"light_candle\") { state, params in","            guard state.has(\"black_candle\") else {","                return .requiresUserInput(hint: \"You need the black candle first.\")","            }","            ","            if state.ritual.lightCandle() {","                return .completed","            } else {","                return .requiresUserInput(hint: \"The candle is already lit.\")","            }","        }","        ","        acts.register(\"read_tome\") { state, params in","            guard state.has(\"forbidden_tome\") else {","                return .requiresUserInput(hint: \"You need the forbidden tome first.\")","            }","            ","            if state.ritual.readTome() {","                return .completed","            } else {","                return .requiresUserInput(hint: \"You have already read from the tome.\")","            }","        }","    }","}"],"highlights":[{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27}],"type":"file"},"Predicates@2.swift":{"type":"file","fileType":"swift","highlights":[{"line":2},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14}],"fileName":"Predicates.swift","syntax":"swift","identifier":"Predicates@2.swift","content":["import Foundation","import StoryKit","","public func rollD20() -> Int { Int.random(in: 1...20) }","public func checkUnder(_ threshold: Int, roll: Int = rollD20()) -> Bool { roll <= threshold }","","public func makePredicates() -> PredicateRegistry<HauntedState> {","    var preds = PredicateRegistry<HauntedState>()","    preds.register(\"has-item\") { state, params in","        guard let id = params[\"item\"] else { return false }","        return state.inventory.contains(id)","    }","    return preds","}"]},"doc://StoryKit/tutorials/table-of-contents":{"role":"overview","url":"\/tutorials\/table-of-contents","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents","title":"Meet StoryKit","abstract":[{"type":"text","text":"StoryKit is a data‑driven engine and toolset for building branching, text‑forward experiences. These tutorials guide you from validating a story, to playing it with a small Swift app, to layering mechanics like checks, effects, and actions."}],"kind":"overview","type":"topic"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Roll-Under-Checks-Predicates","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates","title":"Roll-Under Checks & Predicates","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"kind":"section","type":"section"},"HauntedState@2.swift":{"fileName":"HauntedState.swift","fileType":"swift","syntax":"swift","content":["import StoryKit","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public var health: Int = 10","    public var sanity: Int = 10","    public var inventory: Set<String> = []","    public var flags: Set<String> = []","    public init(start: NodeID) { self.currentNode = start }","}"],"identifier":"HauntedState@2.swift","highlights":[{"line":5},{"line":6},{"line":7},{"line":8}],"type":"file"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Effects-Damage-Sanity-Items-Flags","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags","title":"Effects: Damage, Sanity, Items, Flags","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"kind":"section","type":"section"},"Battle@2.swift":{"type":"file","fileType":"swift","highlights":[{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12}],"syntax":"swift","fileName":"Battle.swift","identifier":"Battle@2.swift","content":["import StoryKit","","extension BoneServant {","    static func registerActions(into acts: inout ActionRegistry<HauntedState>) {","        acts.register(\"check_pursuit\") { state, params in","            if state.boneServant.hasArrived {","                return .requiresUserInput(hint: \"The bone servant has found you!\")","            } else {","                state.boneServant.advance()","                return .completed","            }","        }","    }","}"]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Load-the-Story-Bundle","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle","title":"Load the Story Bundle","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"type":"codeVoice","code":"StoryEngine"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"type":"codeVoice","code":"select(choiceID:)"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Compile-the-Story":{"type":"section","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}],"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Compile-the-Story","kind":"section","title":"Compile the Story","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Compile-the-Story"},"HauntedState@4.swift":{"fileName":"HauntedState.swift","fileType":"swift","syntax":"swift","identifier":"HauntedState@4.swift","content":["import StoryKit","","public struct Ritual: Codable, Sendable {","    public var candleLit: Bool = false","    public var tomeRead: Bool = false","    public var sacrificeMade: Bool = false","    ","    public var isComplete: Bool {","        candleLit && tomeRead && sacrificeMade","    }","    ","    public var nextStep: String? {","        if !candleLit { return \"light_candle\" }","        if !tomeRead { return \"read_tome\" }","        if !sacrificeMade { return \"make_sacrifice\" }","        return nil","    }","}","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public var health: Int = 10","    public var sanity: Int = 10","    public var inventory: Set<String> = []","    public var flags: Set<String> = []","    public var ritual: Ritual = Ritual()","    public init(start: NodeID) { self.currentNode = start }","","    public mutating func gain(_ item: String) { inventory.insert(item) }","    public func has(_ item: String) -> Bool { inventory.contains(item) }","    public mutating func setFlag(_ id: String, to value: Bool) {","        if value { flags.insert(id) } else { flags.remove(id) }","    }","}"],"highlights":[{"line":3},{"line":4},{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":26}],"type":"file"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Designing-Game-State","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State","title":"Designing Game State","abstract":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State":{"abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}],"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State","kind":"section","title":"Define Minimal State","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Define-Minimal-State"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Chase-Mechanics-Bone-Servant-Encounters":{"type":"section","abstract":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}],"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Chase-Mechanics-Bone-Servant-Encounters","kind":"section","title":"Chase Mechanics & Bone Servant Encounters","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Chase-Mechanics-Bone-Servant-Encounters"},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift":{"abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"type":"codeVoice","code":"StoryEngine"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"type":"codeVoice","code":"select(choiceID:)"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}],"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift","kind":"project","title":"Playing a Story with StoryEngine","role":"project","estimatedTime":"35min","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Outcome":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Outcome","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Outcome","title":"Outcome","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/table-of-contents/Building-and-Validating-a-Story":{"type":"topic","abstract":[],"identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Building-and-Validating-a-Story","kind":"article","title":"Building and Validating a Story","role":"article","url":"\/tutorials\/table-of-contents\/building-and-validating-a-story"},"Ritual.swift":{"type":"file","fileType":"swift","highlights":[],"syntax":"swift","fileName":"Ritual.swift","identifier":"Ritual.swift","content":["import StoryKit","","extension Ritual {","    static func registerActions(into acts: inout ActionRegistry<HauntedState>) {","        \/\/ Individual ritual actions will be registered here","    }","}"]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Individual-Actions":{"type":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Individual-Actions","kind":"section","title":"The Final Ritual (Individual Actions)","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#The-Final-Ritual-Individual-Actions"},"Battle.swift":{"fileName":"Battle.swift","fileType":"swift","syntax":"swift","content":["import StoryKit","","extension BoneServant {","    static func registerActions(into acts: inout ActionRegistry<HauntedState>) {","        \/\/ Chase and combat actions will be registered here","    }","}"],"identifier":"Battle.swift","highlights":[],"type":"file"},"Battle@3.swift":{"type":"file","fileType":"swift","highlights":[{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23}],"syntax":"swift","fileName":"Battle.swift","identifier":"Battle@3.swift","content":["import StoryKit","","extension BoneServant {","    static func registerActions(into acts: inout ActionRegistry<HauntedState>) {","        acts.register(\"check_pursuit\") { state, params in","            if state.boneServant.hasArrived {","                return .requiresUserInput(hint: \"The bone servant has found you!\")","            } else {","                state.boneServant.advance()","                return .completed","            }","        }","        ","        acts.register(\"flee_servant\") { state, params in","            let dex = Int(params[\"dex\"] ?? \"12\") ?? 12","            if checkUnder(dex) {","                state.boneServant = BoneServant() \/\/ Reset the servant","                return .completed","            } else {","                state.sanity = max(0, state.sanity - 2)","                return .requiresUserInput(hint: \"You failed to escape!\")","            }","        }","    }","}"]},"Effects@3.swift":{"fileName":"Effects.swift","fileType":"swift","syntax":"swift","identifier":"Effects@3.swift","content":["import StoryKit","","public func registerLoseSanity(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"lose-sanity\") { state, params in","        let amt = Int(params[\"by\"] ?? \"1\") ?? 1","        state.sanity = max(0, state.sanity - amt)","    }","}","","public func registerTakeDamage(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"take-damage\") { state, params in","        let amt = Int(params[\"by\"] ?? \"1\") ?? 1","        state.health = max(0, state.health - amt)","    }","}","","public func registerGainItem(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"gain-item\") { state, params in","        if let id = params[\"item\"] { state.inventory.insert(id) }","    }","}"],"highlights":[{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21}],"type":"file"},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Validating-a-Story":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Validating-a-Story","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Validating-a-Story","title":"Validating a Story","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}],"kind":"section","type":"section"},"Ritual@4.swift":{"type":"file","fileType":"swift","highlights":[{"line":25},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41}],"syntax":"swift","fileName":"Ritual.swift","identifier":"Ritual@4.swift","content":["import StoryKit","","extension Ritual {","    static func registerActions(into acts: inout ActionRegistry<HauntedState>) {","        acts.register(\"light_candle\") { state, params in","            guard state.has(\"black_candle\") else {","                return .requiresUserInput(hint: \"You need the black candle first.\")","            }","            ","            if state.ritual.lightCandle() {","                return .completed","            } else {","                return .requiresUserInput(hint: \"The candle is already lit.\")","            }","        }","        ","        acts.register(\"read_tome\") { state, params in","            guard state.has(\"forbidden_tome\") else {","                return .requiresUserInput(hint: \"You need the forbidden tome first.\")","            }","            ","            if state.ritual.readTome() {","                return .completed","            } else {","                return .requiresUserInput(hint: \"You must light the candle first, or the tome is already read.\")","            }","        }","        ","        acts.register(\"make_sacrifice\") { state, params in","            guard state.has(\"silver_dagger\") else {","                return .requiresUserInput(hint: \"You need the silver dagger first.\")","            }","            ","            if state.ritual.makeSacrifice() {","                \/\/ Ritual complete - activate the bone servant","                state.boneServant.activate()","                return .completed","            } else {","                return .requiresUserInput(hint: \"You have already made the sacrifice.\")","            }","        }","    }","}"]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story":{"type":"topic","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story","kind":"project","title":"Building and Validating a Story","role":"project","estimatedTime":"30min","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}]},"doc://StoryKit/tutorials/table-of-contents/Playing-a-Story-with-StoryEngine":{"role":"article","url":"\/tutorials\/table-of-contents\/playing-a-story-with-storyengine","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Playing-a-Story-with-StoryEngine","title":"Playing a Story with StoryEngine","abstract":[],"kind":"article","type":"topic"},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats":{"type":"section","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}],"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats","kind":"section","title":"StoryKit File Formats","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#StoryKit-File-Formats"},"HauntedState@6.swift":{"fileName":"HauntedState.swift","fileType":"swift","syntax":"swift","content":["import StoryKit","","public struct Ritual: Codable, Sendable {","    public var candleLit: Bool = false","    public var tomeRead: Bool = false","    public var sacrificeMade: Bool = false","    ","    public var isComplete: Bool {","        candleLit && tomeRead && sacrificeMade","    }","    ","    public var nextStep: String? {","        if !candleLit { return \"light_candle\" }","        if !tomeRead { return \"read_tome\" }","        if !sacrificeMade { return \"make_sacrifice\" }","        return nil","    }","    ","    public mutating func lightCandle() -> Bool {","        guard !candleLit else { return false }","        candleLit = true","        return true","    }","}","","public struct BoneServant: Codable, Sendable {","    public var isActive: Bool = false","    public var turnsUntilArrival: Int = 3","    public var currentRoom: String = \"ritual_chamber\"","    ","    public mutating func activate() {","        isActive = true","        turnsUntilArrival = 3","    }","    ","    public mutating func advance() {","        if isActive && turnsUntilArrival > 0 {","            turnsUntilArrival -= 1","        }","    }","    ","    public var hasArrived: Bool { isActive && turnsUntilArrival <= 0 }","}","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public var health: Int = 10","    public var sanity: Int = 10","    public var inventory: Set<String> = []","    public var flags: Set<String> = []","    public var ritual: Ritual = Ritual()","    public var boneServant: BoneServant = BoneServant()","    public init(start: NodeID) { self.currentNode = start }","","    public mutating func gain(_ item: String) { inventory.insert(item) }","    public func has(_ item: String) -> Bool { inventory.contains(item) }","    public mutating func setFlag(_ id: String, to value: Bool) {","        if value { flags.insert(id) } else { flags.remove(id) }","    }","}"],"identifier":"HauntedState@6.swift","highlights":[{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23}],"type":"file"},"AutoSave.swift":{"type":"file","fileType":"swift","highlights":[],"syntax":"swift","fileName":"AutoSave.swift","identifier":"AutoSave.swift","content":["import StoryKit","","public func makeAutoSave(storyID: String) -> @Sendable (HauntedState) async throws -> Void {","    let provider = JSONFileSaveProvider(directory: URL(fileURLWithPath: NSTemporaryDirectory()))","    return makeAutoSaveHandler(storyID: storyID, provider: provider)","}"]},"Predicates@3.swift":{"fileName":"Predicates.swift","fileType":"swift","syntax":"swift","content":["import Foundation","import StoryKit","","public func rollD20() -> Int { Int.random(in: 1...20) }","public func checkUnder(_ threshold: Int, roll: Int = rollD20()) -> Bool { roll <= threshold }","","public func makePredicates() -> PredicateRegistry<HauntedState> {","    var preds = PredicateRegistry<HauntedState>()","    preds.register(\"has-item\") { state, params in","        guard let id = params[\"item\"] else { return false }","        return state.inventory.contains(id)","    }","    addStatAtLeast(to: &preds)","    return preds","}","","public func addStatAtLeast(to preds: inout PredicateRegistry<HauntedState>) {","    preds.register(\"stat-at-least\") { state, params in","        guard let key = params[\"stat\"], let minStr = params[\"min\"], let min = Int(minStr) else { return false }","        switch key {","        case \"health\": return state.health >= min","        case \"sanity\": return state.sanity >= min","        default: return false","        }","    }","}"],"identifier":"Predicates@3.swift","highlights":[{"line":13},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26}],"type":"file"},"HauntedState.swift":{"type":"file","fileType":"swift","highlights":[],"fileName":"HauntedState.swift","syntax":"swift","identifier":"HauntedState.swift","content":["import StoryKit","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public init(start: NodeID) { self.currentNode = start }","}"]},"HauntedState@8.swift":{"fileName":"HauntedState.swift","fileType":"swift","syntax":"swift","identifier":"HauntedState@8.swift","content":["import StoryKit","","public struct Ritual: Codable, Sendable {","    public var candleLit: Bool = false","    public var tomeRead: Bool = false","    public var sacrificeMade: Bool = false","    ","    public var isComplete: Bool {","        candleLit && tomeRead && sacrificeMade","    }","    ","    public var nextStep: String? {","        if !candleLit { return \"light_candle\" }","        if !tomeRead { return \"read_tome\" }","        if !sacrificeMade { return \"make_sacrifice\" }","        return nil","    }","    ","    public mutating func lightCandle() -> Bool {","        guard !candleLit else { return false }","        candleLit = true","        return true","    }","    ","    public mutating func readTome() -> Bool {","        guard !tomeRead else { return false }","        tomeRead = true","        return true","    }","    ","    public mutating func makeSacrifice() -> Bool {","        guard !sacrificeMade else { return false }","        sacrificeMade = true","        return true","    }","}","","public struct BoneServant: Codable, Sendable {","    public var isActive: Bool = false","    public var turnsUntilArrival: Int = 3","    public var currentRoom: String = \"ritual_chamber\"","    ","    public mutating func activate() {","        isActive = true","        turnsUntilArrival = 3","    }","    ","    public mutating func advance() {","        if isActive && turnsUntilArrival > 0 {","            turnsUntilArrival -= 1","        }","    }","    ","    public var hasArrived: Bool { isActive && turnsUntilArrival <= 0 }","}","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public var health: Int = 10","    public var sanity: Int = 10","    public var inventory: Set<String> = []","    public var flags: Set<String> = []","    public var ritual: Ritual = Ritual()","    public var boneServant: BoneServant = BoneServant()","    public init(start: NodeID) { self.currentNode = start }","","    public mutating func gain(_ item: String) { inventory.insert(item) }","    public func has(_ item: String) -> Bool { inventory.contains(item) }","    public mutating func setFlag(_ id: String, to value: Bool) {","        if value { flags.insert(id) } else { flags.remove(id) }","    }","}"],"highlights":[{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35}],"type":"file"},"HauntedState@5.swift":{"type":"file","fileType":"swift","highlights":[{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":46}],"syntax":"swift","fileName":"HauntedState.swift","identifier":"HauntedState@5.swift","content":["import StoryKit","","public struct Ritual: Codable, Sendable {","    public var candleLit: Bool = false","    public var tomeRead: Bool = false","    public var sacrificeMade: Bool = false","    ","    public var isComplete: Bool {","        candleLit && tomeRead && sacrificeMade","    }","    ","    public var nextStep: String? {","        if !candleLit { return \"light_candle\" }","        if !tomeRead { return \"read_tome\" }","        if !sacrificeMade { return \"make_sacrifice\" }","        return nil","    }","}","","public struct BoneServant: Codable, Sendable {","    public var isActive: Bool = false","    public var turnsUntilArrival: Int = 3","    public var currentRoom: String = \"ritual_chamber\"","    ","    public mutating func activate() {","        isActive = true","        turnsUntilArrival = 3","    }","    ","    public mutating func advance() {","        if isActive && turnsUntilArrival > 0 {","            turnsUntilArrival -= 1","        }","    }","    ","    public var hasArrived: Bool { isActive && turnsUntilArrival <= 0 }","}","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public var health: Int = 10","    public var sanity: Int = 10","    public var inventory: Set<String> = []","    public var flags: Set<String> = []","    public var ritual: Ritual = Ritual()","    public var boneServant: BoneServant = BoneServant()","    public init(start: NodeID) { self.currentNode = start }","","    public mutating func gain(_ item: String) { inventory.insert(item) }","    public func has(_ item: String) -> Bool { inventory.contains(item) }","    public mutating func setFlag(_ id: String, to value: Bool) {","        if value { flags.insert(id) } else { flags.remove(id) }","    }","}"]},"Ritual@2.swift":{"fileName":"Ritual.swift","fileType":"swift","syntax":"swift","identifier":"Ritual@2.swift","content":["import StoryKit","","extension Ritual {","    static func registerActions(into acts: inout ActionRegistry<HauntedState>) {","        acts.register(\"light_candle\") { state, params in","            guard state.has(\"black_candle\") else {","                return .requiresUserInput(hint: \"You need the black candle first.\")","            }","            ","            if state.ritual.lightCandle() {","                return .completed","            } else {","                return .requiresUserInput(hint: \"The candle is already lit.\")","            }","        }","    }","}"],"highlights":[{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15}],"type":"file"},"AutoSave@2.swift":{"type":"file","fileType":"swift","highlights":[{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21}],"fileName":"AutoSave.swift","syntax":"swift","identifier":"AutoSave@2.swift","content":["import StoryKit","","public func makeAutoSave(storyID: String) -> @Sendable (HauntedState) async throws -> Void {","    let provider = JSONFileSaveProvider(directory: URL(fileURLWithPath: NSTemporaryDirectory()))","    return makeAutoSaveHandler(storyID: storyID, provider: provider)","}","","func makeEngine(story: Story) -> StoryEngine<HauntedState> {","    var preds = PredicateRegistry<HauntedState>()","    var effs = EffectRegistry<HauntedState>()","    var acts = ActionRegistry<HauntedState>()","    let autosave = try? makeAutoSave(storyID: story.metadata.id)","    return StoryEngine(","        story: story,","        initialState: HauntedState(start: story.start),","        predicateRegistry: preds,","        effectRegistry: effs,","        actionRegistry: acts,","        autosave: autosave","    )","}"]},"Effects@2.swift":{"fileName":"Effects.swift","fileType":"swift","syntax":"swift","identifier":"Effects@2.swift","content":["import StoryKit","","public func registerLoseSanity(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"lose-sanity\") { state, params in","        let amt = Int(params[\"by\"] ?? \"1\") ?? 1","        state.sanity = max(0, state.sanity - amt)","    }","}","","public func registerTakeDamage(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"take-damage\") { state, params in","        let amt = Int(params[\"by\"] ?? \"1\") ?? 1","        state.health = max(0, state.health - amt)","    }","}"],"highlights":[{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15}],"type":"file"},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Story-Node-Structure":{"type":"section","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Story-Node-Structure","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Story-Node-Structure","kind":"section","title":"Story Node Structure","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Outcome":{"url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Outcome","type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Outcome","kind":"section","title":"Outcome","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"type":"codeVoice","code":"StoryEngine"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"type":"codeVoice","code":"select(choiceID:)"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes":{"url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Create-the-Engine-Print-Nodes","type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes","kind":"section","title":"Create the Engine & Print Nodes","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"type":"codeVoice","code":"StoryEngine"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"type":"codeVoice","code":"select(choiceID:)"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Text-Content":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Text-Content","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Text-Content","title":"Text Content","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks":{"abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","kind":"project","title":"Checks, Effects, Actions, Battles, and the Ritual","role":"project","estimatedTime":"1hr 0min","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks"},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Command-Line-Interface","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface","title":"Command-Line Interface","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}],"kind":"section","type":"section"},"Predicates.swift":{"fileName":"Predicates.swift","fileType":"swift","syntax":"swift","content":["import Foundation","","public func rollD20() -> Int { Int.random(in: 1...20) }","public func checkUnder(_ threshold: Int, roll: Int = rollD20()) -> Bool { roll <= threshold }"],"identifier":"Predicates.swift","highlights":[],"type":"file"},"Effects.swift":{"type":"file","fileType":"swift","highlights":[],"syntax":"swift","fileName":"Effects.swift","identifier":"Effects.swift","content":["import StoryKit","","public func registerLoseSanity(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"lose-sanity\") { state, params in","        let amt = Int(params[\"by\"] ?? \"1\") ?? 1","        state.sanity = max(0, state.sanity - amt)","    }","}"]},"doc://StoryKit/tutorials/table-of-contents/Checks,-Effects,-Actions,-Battles,-and-the-Ritual":{"type":"topic","abstract":[],"identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Checks,-Effects,-Actions,-Battles,-and-the-Ritual","kind":"article","title":"Checks, Effects, Actions, Battles, and the Ritual","role":"article","url":"\/tutorials\/table-of-contents\/checks,-effects,-actions,-battles,-and-the-ritual"},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Project-Setup","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup","title":"Project Setup","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}],"kind":"section","type":"section"},"HauntedState@7.swift":{"type":"file","fileType":"swift","highlights":[{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29}],"fileName":"HauntedState.swift","syntax":"swift","identifier":"HauntedState@7.swift","content":["import StoryKit","","public struct Ritual: Codable, Sendable {","    public var candleLit: Bool = false","    public var tomeRead: Bool = false","    public var sacrificeMade: Bool = false","    ","    public var isComplete: Bool {","        candleLit && tomeRead && sacrificeMade","    }","    ","    public var nextStep: String? {","        if !candleLit { return \"light_candle\" }","        if !tomeRead { return \"read_tome\" }","        if !sacrificeMade { return \"make_sacrifice\" }","        return nil","    }","    ","    public mutating func lightCandle() -> Bool {","        guard !candleLit else { return false }","        candleLit = true","        return true","    }","    ","    public mutating func readTome() -> Bool {","        guard !tomeRead else { return false }","        tomeRead = true","        return true","    }","}","","public struct BoneServant: Codable, Sendable {","    public var isActive: Bool = false","    public var turnsUntilArrival: Int = 3","    public var currentRoom: String = \"ritual_chamber\"","    ","    public mutating func activate() {","        isActive = true","        turnsUntilArrival = 3","    }","    ","    public mutating func advance() {","        if isActive && turnsUntilArrival > 0 {","            turnsUntilArrival -= 1","        }","    }","    ","    public var hasArrived: Bool { isActive && turnsUntilArrival <= 0 }","}","","public struct HauntedState: StoryState, Codable, Sendable {","    public var currentNode: NodeID","    public var health: Int = 10","    public var sanity: Int = 10","    public var inventory: Set<String> = []","    public var flags: Set<String> = []","    public var ritual: Ritual = Ritual()","    public var boneServant: BoneServant = BoneServant()","    public init(start: NodeID) { self.currentNode = start }","","    public mutating func gain(_ item: String) { inventory.insert(item) }","    public func has(_ item: String) -> Bool { inventory.contains(item) }","    public mutating func setFlag(_ id: String, to value: Bool) {","        if value { flags.insert(id) } else { flags.remove(id) }","    }","}"]},"Effects@4.swift":{"fileName":"Effects.swift","fileType":"swift","syntax":"swift","identifier":"Effects@4.swift","content":["import StoryKit","","public func registerLoseSanity(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"lose-sanity\") { state, params in","        let amt = Int(params[\"by\"] ?? \"1\") ?? 1","        state.sanity = max(0, state.sanity - amt)","    }","}","","public func registerTakeDamage(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"take-damage\") { state, params in","        let amt = Int(params[\"by\"] ?? \"1\") ?? 1","        state.health = max(0, state.health - amt)","    }","}","","public func registerGainItem(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"gain-item\") { state, params in","        if let id = params[\"item\"] { state.inventory.insert(id) }","    }","}","","public func registerSetFlag(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"set-flag\") { state, params in","        guard let id = params[\"id\"], let val = params[\"value\"] else { return }","        if (val as NSString).boolValue { state.flags.insert(id) } else { state.flags.remove(id) }","    }","}","","public func registerSpawn(into effs: inout EffectRegistry<HauntedState>) {","    effs.register(\"spawn\") { state, params in","        guard let entity = params[\"entity\"] else { return }","        \/\/ Set flag to track spawned entity for combat system","        state.setFlag(\"spawned_\\(entity)\", to: true)","        \/\/ Could also set current enemy type for battle system","        state.setFlag(\"current_enemy\", to: true)","    }","}"],"highlights":[{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38}],"type":"file"}}}