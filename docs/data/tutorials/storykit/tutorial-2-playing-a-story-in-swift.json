{"schemaVersion":{"major":0,"minor":3,"patch":0},"hierarchy":{"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents","paths":[["doc:\/\/StoryKit\/tutorials\/table-of-contents","doc:\/\/StoryKit\/tutorials\/table-of-contents\/$volume","doc:\/\/StoryKit\/tutorials\/table-of-contents\/Playing-a-Story-with-StoryEngine"]],"modules":[{"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Building-and-Validating-a-Story","projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story","sections":[{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Validating-a-Story"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Story-Node-Structure"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Text-Content"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Compile-the-Story"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Outcome"}]}]},{"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Playing-a-Story-with-StoryEngine","projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift","sections":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Outcome","kind":"task"}]}]},{"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Checks,-Effects,-Actions,-Battles,-and-the-Ritual","projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","sections":[{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Chase-Mechanics-Bone-Servant-Encounters"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Individual-Actions"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Outcome"}]}]}]},"sections":[{"title":"Playing a Story with StoryEngine","content":[{"type":"paragraph","inlineContent":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"StoryKit’s runtime model is deliberately small. Your application defines state by conforming to "},{"type":"codeVoice","code":"StoryState"},{"type":"text","text":" (at minimum, a "},{"type":"codeVoice","code":"currentNode"},{"type":"text","text":" of type "},{"type":"codeVoice","code":"NodeID"},{"type":"text","text":"). Predicates, effects, and actions live in registries that map string identifiers from your content to sendable closures in your app’s domain. The engine is an actor that owns the story and state; it filters choices through predicates, applies effects when moving between nodes, and (optionally) triggers autosave after transitions and actions. There is no "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method: the engine exposes current context and moves forward only when your code calls "},{"type":"codeVoice","code":"select"},{"type":"text","text":" with a specific choice id."}]},{"type":"paragraph","inlineContent":[{"text":"The CLI runner you build here is intentionally simple: print text, present choices, read a line, and select. In the next tutorial you’ll enrich this with mechanics like skill checks, battles, and the final ritual action. For now, focus on the runtime plumbing—loading, printing, choosing—so the next layer has a clean place to land.","type":"text"}]}],"kind":"hero","chapter":"Playing a Story with StoryEngine","estimatedTimeInMinutes":35},{"tasks":[{"title":"Project Setup","stepsSection":[{"content":[{"inlineContent":[{"type":"text","text":"Initialize a package and open it in your editor. Replace "},{"type":"codeVoice","code":"Package.swift"},{"type":"text","text":" and scaffold a minimal "},{"type":"codeVoice","code":"main.swift"},{"type":"text","text":"."}],"type":"paragraph"}],"runtimePreview":null,"code":"02-01-package.swift","caption":[],"type":"step","media":null}],"anchor":"Project-Setup","contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Create a new executable Swift package and add a dependency on StoryKit. During development, a path dependency is convenient if the package is adjacent to your StoryKit checkout; for teams, pin to a Git revision or a version tag. The sample ","type":"text"},{"code":"Package.swift","type":"codeVoice"},{"text":" below uses a path dependency for local builds.","type":"text"}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}]},{"contentSection":[{"mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Start with a tiny command that accepts the path to a compiled "},{"type":"codeVoice","code":".storybundle"},{"type":"text","text":". Using a positional argument keeps it easy to type and feels like other Unix tools. You can add options and subcommands later as your runner grows."}]},{"type":"paragraph","inlineContent":[{"text":"To explore the API surface, the code below shows the whole file — each step calls out the specific line to add and why.","type":"text"},{"text":" ","type":"text"},{"text":"See the ArgumentParser docs to learn more: https:\/\/github.com\/apple\/swift-argument-parser","type":"text"}]}],"kind":"contentAndMedia"}],"anchor":"Command-Line-Interface","title":"Command-Line Interface","stepsSection":[{"type":"step","caption":[],"content":[{"inlineContent":[{"text":"Create the command structure with a type that conforms to ","type":"text"},{"code":"ParsableCommand","type":"codeVoice"},{"text":" and a simple abstract description.","type":"text"}],"type":"paragraph"}],"media":null,"code":"02-05-Main.swift","runtimePreview":null},{"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Declare a positional argument for the bundle path using the ","type":"text"},{"code":"@Argument","type":"codeVoice"},{"text":" property wrapper. Positional keeps the command short and obvious: ","type":"text"},{"code":"haunted --help","type":"codeVoice"},{"text":" vs ","type":"text"},{"code":"haunted <bundle>","type":"codeVoice"},{"text":".","type":"text"}]}],"media":null,"code":"02-05-Main@2.swift","runtimePreview":null},{"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add a "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" function (even a skeleton is fine) that will load the bundle and kick off the loop you’ll build next."}]}],"media":null,"code":"02-05-Main@3.swift","runtimePreview":null}]},{"contentSection":[{"content":[{"inlineContent":[{"type":"text","text":"Implement a tiny "},{"type":"codeVoice","code":"HauntedState"},{"type":"text","text":" conforming to "},{"type":"codeVoice","code":"StoryState"},{"type":"text","text":". The engine only requires "},{"type":"codeVoice","code":"currentNode"},{"type":"text","text":"; everything else is up to you. This design keeps content and mechanics separate: the story stays declarative, and your app owns the rules. You can evolve health, sanity, inventory, or flags without rewriting content, and reuse the same story in different apps with different state models. StoryKit, for its part, stays focused on traversal and validation rather than your game’s details."}],"type":"paragraph"}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"anchor":"Define-Minimal-State","title":"Define Minimal State","stepsSection":[{"content":[{"inlineContent":[{"type":"text","text":"Add a single-file state definition. Keep it small; you’ll extend it later."}],"type":"paragraph"}],"caption":[],"type":"step","runtimePreview":null,"media":null,"code":"02-02-HauntedState.swift"}]},{"title":"Load the Story Bundle","anchor":"Load-the-Story-Bundle","contentSection":[{"mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"text":"Use ","type":"text"},{"code":"StoryBundleLoader","type":"codeVoice"},{"text":" to load a compiled bundle. A bundle contains ","type":"text"},{"code":"manifest.json","type":"codeVoice"},{"text":", ","type":"text"},{"code":"graph.json","type":"codeVoice"},{"text":", and a ","type":"text"},{"code":"texts\/","type":"codeVoice"},{"text":" directory; the loader decodes ","type":"text"},{"code":"graph.json","type":"codeVoice"},{"text":" into a ","type":"text"},{"code":"Story","type":"codeVoice"},{"text":". Markdown files are read on demand and provide a performant, memory‑efficient, concurrency‑safe caching mechanism for excellent steady‑state performance. This keeps authoring files out of your runtime while giving you fast text lookups when you need them.","type":"text"}]}],"kind":"contentAndMedia"}],"stepsSection":[{"code":"02-03-LoadBundle.swift","media":null,"runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement a helper that returns a "},{"type":"codeVoice","code":"Story"},{"type":"text","text":" for a bundle path. This keeps "},{"type":"codeVoice","code":"main.swift"},{"type":"text","text":" clean and makes testing straightforward."}]}],"caption":[]}]},{"title":"Create the Engine & Print Nodes","anchor":"Create-the-Engine-Print-Nodes","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Construct the engine with your "},{"code":"Story","type":"codeVoice"},{"text":", ","type":"text"},{"code":"HauntedState","type":"codeVoice"},{"text":", and (for now) empty predicate\/effect\/action registries. The engine starts at ","type":"text"},{"code":"story.start","type":"codeVoice"},{"text":"; there’s no ","type":"text"},{"code":"run()","type":"codeVoice"},{"text":"—you stay in control. Build the loop as a series of small, focused steps so it’s easy to reason about and test. Reading from stdin is fine for a first pass; production apps swap this for UI, but the rhythm remains the same: render, choose, advance.","type":"text"}]}]}],"stepsSection":[{"content":[{"inlineContent":[{"type":"text","text":"Ask for the current node. Keeping this explicit makes state inspection and testing straightforward."}],"type":"paragraph"}],"type":"step","media":null,"runtimePreview":null,"caption":[],"code":"02-04-EngineLoop.swift"},{"content":[{"inlineContent":[{"type":"text","text":"Print a clear header like "},{"type":"codeVoice","code":"=== <node id> ==="},{"type":"text","text":" to ground the reader before the prose."}],"type":"paragraph"}],"type":"step","media":null,"runtimePreview":null,"caption":[],"code":"02-04-EngineLoop@2.swift"},{"content":[{"inlineContent":[{"text":"Fetch and print the node’s text using ","type":"text"},{"code":"BundleTextProvider","type":"codeVoice"},{"text":" and the node’s ","type":"text"},{"code":"TextRef","type":"codeVoice"},{"text":". StoryKit keeps prose separate from the graph so you decide how it’s presented.","type":"text"}],"type":"paragraph"}],"type":"step","media":null,"runtimePreview":null,"caption":[],"code":"02-04-EngineLoop@3.swift"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"List the available choices with 1‑based indices. This keeps input mapping simple and readable."}]}],"type":"step","media":null,"runtimePreview":null,"caption":[],"code":"02-04-EngineLoop@4.swift"},{"content":[{"inlineContent":[{"text":"Read input from stdin and map it to a selected choice. This keeps I\/O concerns out of the engine proper.","type":"text"}],"type":"paragraph"}],"type":"step","media":null,"runtimePreview":null,"caption":[],"code":"02-04-EngineLoop@5.swift"},{"content":[{"inlineContent":[{"type":"text","text":"Advance the engine by calling "},{"type":"codeVoice","code":"select(choiceID:)"},{"type":"text","text":". Behind the scenes the engine evaluates predicates, applies effects, transitions to the destination, applies destination on‑enter effects, and then returns control to you for the next render."}],"type":"paragraph"}],"type":"step","media":null,"runtimePreview":null,"caption":[],"code":"02-04-EngineLoop@5.swift"}]},{"title":"Outcome","anchor":"Outcome","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"inlineContent":[{"text":"You now have a small CLI that can load and play a StoryKit bundle: a positional-argument command, a minimal ","type":"text"},{"code":"StoryState","type":"codeVoice"},{"text":", and a loop that prints headers, text, and choices and advances the engine. StoryKit handled loading\/decoding, text caching, concurrency safety, and predicate\/effect application; next you’ll add checks, effects, and actions.","type":"text"}],"type":"paragraph"}]}],"stepsSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Proceed to learn checks, effects, actions, and autosave.","type":"text"}]}],"media":null,"runtimePreview":null,"code":null,"caption":[],"type":"step"}]}],"kind":"tasks"},{"featuredEyebrow":"Tutorial","title":"Checks, Effects, Actions, Battles, and the Ritual","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"kind":"callToAction","action":{"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","isActive":true,"type":"reference","overridingTitleInlineContent":[{"type":"text","text":"Get started"}],"overridingTitle":"Get started"}}],"identifier":{"url":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift"]}],"metadata":{"category":"StoryKit","title":"Playing a Story with StoryEngine","categoryPathComponent":"table-of-contents","role":"project"},"kind":"project","references":{"doc://StoryKit/tutorials/table-of-contents/Checks,-Effects,-Actions,-Battles,-and-the-Ritual":{"type":"topic","abstract":[],"identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Checks,-Effects,-Actions,-Battles,-and-the-Ritual","kind":"article","title":"Checks, Effects, Actions, Battles, and the Ritual","role":"article","url":"\/tutorials\/table-of-contents\/checks,-effects,-actions,-battles,-and-the-ritual"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Chase-Mechanics-Bone-Servant-Encounters":{"type":"section","abstract":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}],"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Chase-Mechanics-Bone-Servant-Encounters","kind":"section","title":"Chase Mechanics & Bone Servant Encounters","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Chase-Mechanics-Bone-Servant-Encounters"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Designing-Game-State","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State","title":"Designing Game State","abstract":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Story-Node-Structure":{"type":"section","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Story-Node-Structure","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Story-Node-Structure","kind":"section","title":"Story Node Structure","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}]},"02-04-EngineLoop@4.swift":{"identifier":"02-04-EngineLoop@4.swift","fileType":"swift","type":"file","fileName":"EngineLoop.swift","highlights":[{"line":17},{"line":23},{"line":24},{"line":25},{"line":26}],"syntax":"swift","content":["import Foundation","import StoryKit","","public func play(story: Story, bundlePath: String) throws {","    var predicates = PredicateRegistry<HauntedState>()","    var effects = EffectRegistry<HauntedState>()","    var actions = ActionRegistry<HauntedState>()","","    let engine = StoryEngine(","        story: story,","        initialState: HauntedState(start: story.start),","        predicateRegistry: predicates,","        effectRegistry: effects,","        actionRegistry: actions","    )","","    \/\/ Step 4: show choices after printing prose","    let textProvider = BundleTextProvider(bundle: StoryBundleLayout(root: URL(fileURLWithPath: bundlePath)))","    if let node = await engine.currentNode() {","        print(\"\\n=== \\(node.id.rawValue) ===\\n\")","        let text = try textProvider.text(for: node.text)","        print(\"\\n\\(text)\\n\")","        let choices = await engine.availableChoices()","        for (idx, c) in choices.enumerated() {","            print(\"  [\\(idx + 1)] \\(c.id.rawValue)\")","        }","    }","}",""]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes":{"url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Create-the-Engine-Print-Nodes","type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes","kind":"section","title":"Create the Engine & Print Nodes","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"type":"codeVoice","code":"StoryEngine"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"type":"codeVoice","code":"select(choiceID:)"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}]},"02-01-package.swift":{"identifier":"02-01-package.swift","fileType":"swift","fileName":"Package.swift","type":"file","highlights":[],"syntax":"swift","content":["\/\/ swift-tools-version: 6.2","import PackageDescription","","let package = Package(","    name: \"HauntedCLIRunner\",","    platforms: [ .macOS(\"26.0\") ],","    products: [ .executable(name: \"haunted\", targets: [\"HauntedCLIRunner\"]) ],","    dependencies: [","        \/\/ Use a local path to the StoryKit package under development","        .package(path: \"..\/StoryKit\"),","        .package(url: \"https:\/\/github.com\/apple\/swift-argument-parser\", from: \"1.5.0\")","    ],","    targets: [","        .executableTarget(","            name: \"HauntedCLIRunner\",","            dependencies: [","                .product(name: \"StoryKit\", package: \"StoryKit\"),","                .product(name: \"ArgumentParser\", package: \"swift-argument-parser\")","            ]","        )","    ]",")",""]},"02-05-Main@3.swift":{"syntax":"swift","fileName":"Main.swift","fileType":"swift","content":["import Foundation","import ArgumentParser","import StoryKit","","@main","struct Haunted: ParsableCommand {","    static let configuration = CommandConfiguration(abstract: \"Play a StoryKit bundle\")","","    @Argument(help: \"Path to compiled .storybundle directory\")","    var bundlePath: String","","    func run() throws {","        let story = try loadStory(from: bundlePath)","        try play(story: story, bundlePath: bundlePath)","    }","}",""],"identifier":"02-05-Main@3.swift","type":"file","highlights":[{"line":11},{"line":12},{"line":13},{"line":14},{"line":15}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Project-Setup","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup","title":"Project Setup","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Outcome":{"url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Outcome","type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Outcome","kind":"section","title":"Outcome","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"type":"codeVoice","code":"StoryEngine"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"type":"codeVoice","code":"select(choiceID:)"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}]},"02-04-EngineLoop@5.swift":{"identifier":"02-04-EngineLoop@5.swift","fileType":"swift","type":"file","fileName":"EngineLoop.swift","highlights":[],"syntax":"swift","content":["import Foundation","import StoryKit","","public func play(story: Story, bundlePath: String) throws {","    var predicates = PredicateRegistry<HauntedState>()","    var effects = EffectRegistry<HauntedState>()","    var actions = ActionRegistry<HauntedState>()","","    let engine = StoryEngine(","        story: story,","        initialState: HauntedState(start: story.start),","        predicateRegistry: predicates,","        effectRegistry: effects,","        actionRegistry: actions","    )","","    let textProvider = BundleTextProvider(bundle: StoryBundleLayout(root: URL(fileURLWithPath: bundlePath)))","","    while true {","        guard let node = await engine.currentNode() else { break }","        print(\"\\n=== \\(node.id.rawValue) ===\\n\")","        let text = try textProvider.text(for: node.text)","        print(\"\\n\\(text)\\n\")","        let choices = await engine.availableChoices()","        if choices.isEmpty { break }","        for (idx, c) in choices.enumerated() {","            print(\"  [\\(idx + 1)] \\(c.title ?? c.id.rawValue)\")","        }","        print(\"\\nChoose: \", terminator: \"\")","        guard let line = readLine(), let n = Int(line), n > 0, n <= choices.count else { continue }","        let selected = choices[n - 1]","        _ = try await engine.select(choiceID: selected.id)","    }","}",""]},"doc://StoryKit/tutorials/table-of-contents":{"role":"overview","url":"\/tutorials\/table-of-contents","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents","title":"Meet StoryKit","abstract":[{"type":"text","text":"StoryKit is a data‑driven engine and toolset for building branching, text‑forward experiences. These tutorials guide you from validating a story, to playing it with a small Swift app, to layering mechanics like checks, effects, and actions."}],"kind":"overview","type":"topic"},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Outcome":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Outcome","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Outcome","title":"Outcome","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Individual-Actions":{"type":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Individual-Actions","kind":"section","title":"The Final Ritual (Individual Actions)","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#The-Final-Ritual-Individual-Actions"},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Command-Line-Interface","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface","title":"Command-Line Interface","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats":{"type":"section","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}],"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats","kind":"section","title":"StoryKit File Formats","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#StoryKit-File-Formats"},"02-04-EngineLoop@2.swift":{"identifier":"02-04-EngineLoop@2.swift","fileType":"swift","type":"file","fileName":"EngineLoop.swift","highlights":[{"line":17},{"line":18},{"line":19},{"line":20},{"line":22}],"syntax":"swift","content":["import Foundation","import StoryKit","","public func play(story: Story, bundlePath: String) throws {","    var predicates = PredicateRegistry<HauntedState>()","    var effects = EffectRegistry<HauntedState>()","    var actions = ActionRegistry<HauntedState>()","","    let engine = StoryEngine(","        story: story,","        initialState: HauntedState(start: story.start),","        predicateRegistry: predicates,","        effectRegistry: effects,","        actionRegistry: actions","    )","","    \/\/ Step 2: print a header for the current node","    if let node = await engine.currentNode() {","        print(\"\\n=== \\(node.id.rawValue) ===\\n\")","    }","}",""]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Validating-a-Story":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Validating-a-Story","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Validating-a-Story","title":"Validating a Story","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift":{"abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"type":"codeVoice","code":"StoryEngine"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"type":"codeVoice","code":"select(choiceID:)"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}],"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift","kind":"project","title":"Playing a Story with StoryEngine","role":"project","estimatedTime":"35min","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift"},"02-04-EngineLoop@3.swift":{"fileName":"EngineLoop.swift","content":["import Foundation","import StoryKit","","public func play(story: Story, bundlePath: String) throws {","    var predicates = PredicateRegistry<HauntedState>()","    var effects = EffectRegistry<HauntedState>()","    var actions = ActionRegistry<HauntedState>()","","    let engine = StoryEngine(","        story: story,","        initialState: HauntedState(start: story.start),","        predicateRegistry: predicates,","        effectRegistry: effects,","        actionRegistry: actions","    )","","    \/\/ Step 3: print node header and prose","    let textProvider = BundleTextProvider(bundle: StoryBundleLayout(root: URL(fileURLWithPath: bundlePath)))","    if let node = await engine.currentNode() {","        print(\"\\n=== \\(node.id.rawValue) ===\\n\")","        let text = try textProvider.text(for: node.text)","        print(\"\\n\\(text)\\n\")","    }","}",""],"fileType":"swift","identifier":"02-04-EngineLoop@3.swift","syntax":"swift","highlights":[{"line":17},{"line":18},{"line":21},{"line":22}],"type":"file"},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story":{"type":"topic","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story","kind":"project","title":"Building and Validating a Story","role":"project","estimatedTime":"30min","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks":{"abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","kind":"project","title":"Checks, Effects, Actions, Battles, and the Ritual","role":"project","estimatedTime":"1hr 0min","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks"},"02-03-LoadBundle.swift":{"content":["import Foundation","import StoryKit","","public func loadStory(from bundlePath: String) throws -> Story {","    let url = URL(fileURLWithPath: bundlePath)","    let layout = StoryBundleLayout(root: url)","    return try StoryBundleLoader().load(from: layout)","}",""],"fileType":"swift","identifier":"02-03-LoadBundle.swift","syntax":"swift","fileName":"LoadBundle.swift","highlights":[],"type":"file"},"02-04-EngineLoop.swift":{"fileName":"EngineLoop.swift","content":["import Foundation","import StoryKit","","public func play(story: Story, bundlePath: String) throws {","    var predicates = PredicateRegistry<HauntedState>()","    var effects = EffectRegistry<HauntedState>()","    var actions = ActionRegistry<HauntedState>()","","    let engine = StoryEngine(","        story: story,","        initialState: HauntedState(start: story.start),","        predicateRegistry: predicates,","        effectRegistry: effects,","        actionRegistry: actions","    )","","    \/\/ Step 1: ask for the current node","    let _ = await engine.currentNode()","}"],"identifier":"02-04-EngineLoop.swift","fileType":"swift","syntax":"swift","highlights":[],"type":"file"},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Compile-the-Story":{"type":"section","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}],"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Compile-the-Story","kind":"section","title":"Compile the Story","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Compile-the-Story"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Effects-Damage-Sanity-Items-Flags","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags","title":"Effects: Damage, Sanity, Items, Flags","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"kind":"section","type":"section"},"02-05-Main.swift":{"content":["import Foundation","import ArgumentParser","import StoryKit","","@main","struct Haunted: ParsableCommand {","    static let configuration = CommandConfiguration(abstract: \"Play a StoryKit bundle\")","}"],"fileType":"swift","identifier":"02-05-Main.swift","syntax":"swift","fileName":"Main.swift","highlights":[],"type":"file"},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Load-the-Story-Bundle","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle","title":"Load the Story Bundle","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"type":"codeVoice","code":"StoryEngine"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"type":"codeVoice","code":"select(choiceID:)"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/table-of-contents/Playing-a-Story-with-StoryEngine":{"role":"article","url":"\/tutorials\/table-of-contents\/playing-a-story-with-storyengine","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Playing-a-Story-with-StoryEngine","title":"Playing a Story with StoryEngine","abstract":[],"kind":"article","type":"topic"},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State":{"abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}],"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State","kind":"section","title":"Define Minimal State","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Define-Minimal-State"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Outcome":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Outcome","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Outcome","title":"Outcome","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"kind":"section","type":"section"},"02-02-HauntedState.swift":{"fileName":"HauntedState.swift","content":["import StoryKit","","public struct HauntedState: StoryState {","    public var currentNode: NodeID","    public init(start: NodeID) { self.currentNode = start }","}",""],"identifier":"02-02-HauntedState.swift","fileType":"swift","syntax":"swift","highlights":[],"type":"file"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Roll-Under-Checks-Predicates","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates","title":"Roll-Under Checks & Predicates","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"kind":"section","type":"section"},"02-05-Main@2.swift":{"content":["import Foundation","import ArgumentParser","import StoryKit","","@main","struct Haunted: ParsableCommand {","    static let configuration = CommandConfiguration(abstract: \"Play a StoryKit bundle\")","","    @Argument(help: \"Path to compiled .storybundle directory\")","    var bundlePath: String","}",""],"fileType":"swift","identifier":"02-05-Main@2.swift","syntax":"swift","fileName":"Main.swift","highlights":[{"line":8},{"line":9},{"line":10},{"line":12}],"type":"file"},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Text-Content":{"role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Text-Content","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Text-Content","title":"Text Content","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}],"kind":"section","type":"section"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds":{"abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}],"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds","kind":"section","title":"Autosave Between Rounds","role":"pseudoSymbol","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Autosave-Between-Rounds"},"doc://StoryKit/tutorials/table-of-contents/Building-and-Validating-a-Story":{"type":"topic","abstract":[],"identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Building-and-Validating-a-Story","kind":"article","title":"Building and Validating a Story","role":"article","url":"\/tutorials\/table-of-contents\/building-and-validating-a-story"}}}