{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story"},"hierarchy":{"modules":[{"projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story","sections":[{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Validating-a-Story","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Story-Node-Structure","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Text-Content","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Compile-the-Story","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Outcome","kind":"task"}]}],"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Building-and-Validating-a-Story"},{"projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift","sections":[{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State","kind":"task"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Outcome","kind":"task"}]}],"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Playing-a-Story-with-StoryEngine"},{"projects":[{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","sections":[{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Entities-Multi-Round-Battles-with-Flee"},{"kind":"task","reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Ordered-Sequence"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds","kind":"task"},{"reference":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Outcome","kind":"task"}]}],"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Checks,-Effects,-Actions,-Battles,-and-the-Ritual"}],"reference":"doc:\/\/StoryKit\/tutorials\/table-of-contents","paths":[["doc:\/\/StoryKit\/tutorials\/table-of-contents","doc:\/\/StoryKit\/tutorials\/table-of-contents\/$volume","doc:\/\/StoryKit\/tutorials\/table-of-contents\/Building-and-Validating-a-Story"]]},"schemaVersion":{"major":0,"minor":3,"patch":0},"variants":[{"paths":["\/tutorials\/storykit\/tutorial-1-building-your-first-story"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"category":"StoryKit","role":"project","categoryPathComponent":"table-of-contents","title":"Building and Validating a Story"},"kind":"project","sections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The goals are practical and conceptual. Practically, you’ll learn how "},{"code":"story.json","type":"codeVoice"},{"type":"text","text":" declares nodes and choices, how Markdown sections provide prose for each node, and how compiled "},{"code":".storybundle","type":"codeVoice"},{"type":"text","text":" directories package everything an app needs. Conceptually, you’ll see how the validator’s structural, flow, and content checks help you spot missing starts, duplicate choice identifiers, bad destinations, and mismatches between your graph and your Markdown."}]}],"kind":"hero","estimatedTimeInMinutes":30,"title":"Building and Validating a Story","chapter":"Building and Validating a Story"},{"tasks":[{"anchor":"StoryKit-File-Formats","title":"StoryKit File Formats","stepsSection":[{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Inspect a minimal ","type":"text"},{"code":"story.json","type":"codeVoice"},{"text":" excerpt.","type":"text"}]}],"type":"step","media":null,"code":"01-format-story.json","runtimePreview":null},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Inspect a Markdown file with multiple node sections.","type":"text"}]}],"type":"step","media":null,"code":"01-format-haunted.txt","runtimePreview":null},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Inspect a compiled bundle directory layout.","type":"text"}]}],"type":"step","media":null,"code":"01-format-bundle.txt","runtimePreview":null}],"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"StoryKit authoring centers on three artifacts that work together: the story graph (","type":"text"},{"code":"story.json","type":"codeVoice"},{"text":"), prose (","type":"text"},{"code":"texts\/*.md","type":"codeVoice"},{"text":"), and compiled bundles (","type":"text"},{"code":".storybundle","type":"codeVoice"},{"text":"). Keeping these boundaries clean makes iteration fast and validation meaningful.","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"story.json","type":"codeVoice"},{"type":"text","text":" is the brain: it declares a starting node ("},{"code":"start","type":"codeVoice"},{"type":"text","text":") and a dictionary of "},{"code":"nodes","type":"codeVoice"},{"type":"text","text":". Each node includes an "},{"code":"id","type":"codeVoice"},{"type":"text","text":", a "},{"code":"text","type":"codeVoice"},{"type":"text","text":" reference pointing to Markdown ("},{"code":"file","type":"codeVoice"},{"type":"text","text":" + "},{"code":"section","type":"codeVoice"},{"type":"text","text":"), a list of "},{"code":"choices","type":"codeVoice"},{"type":"text","text":" (each with an "},{"code":"id","type":"codeVoice"},{"type":"text","text":" and a "},{"code":"destination","type":"codeVoice"},{"type":"text","text":"), and optional predicate\/effect descriptors and declarative "},{"code":"actors","type":"codeVoice"},{"type":"text","text":". The file is canonical for traversal and static checks."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Markdown is the voice: each file in "},{"code":"texts\/","type":"codeVoice"},{"type":"text","text":" can hold multiple node sections, delimited by lines like "},{"code":"=== node: foyer ===","type":"codeVoice"},{"type":"text","text":". This is where you write prose that breathes—multi–paragraph descriptions, atmospheric beats, and encounter narration. The "},{"code":"TextSectionParser","type":"codeVoice"},{"type":"text","text":" splits big files into section maps at load time."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"code":".storybundle","type":"codeVoice"},{"type":"text","text":" is the runtime package: it contains "},{"code":"manifest.json","type":"codeVoice"},{"type":"text","text":" (metadata + "},{"code":"graph.json","type":"codeVoice"},{"type":"text","text":" hash), "},{"code":"graph.json","type":"codeVoice"},{"type":"text","text":" (a compiled copy of the story JSON), and a "},{"code":"texts\/","type":"codeVoice"},{"type":"text","text":" folder copied from source. Apps load bundles with "},{"code":"StoryBundleLoader","type":"codeVoice"},{"type":"text","text":" to avoid touching your authoring directory structure at runtime."}]}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"text":"Below are small excerpts. Your real files will be larger, but these convey the schema and the Markdown delimiter.","type":"text"}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}]},{"anchor":"Validating-a-Story","title":"Validating a Story","stepsSection":[{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Download the starter files and unzip them into a convenient folder (for example, ","type":"text"},{"code":"~\/Downloads\/HauntedStarter","type":"codeVoice"},{"text":"). You’ll pass this folder to the validator and compiler.","type":"text"}]}],"type":"step","media":null,"code":null,"runtimePreview":null},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Build the package and run the validator from the root of the StoryKit checkout: ","type":"text"},{"code":"swift build","type":"codeVoice"},{"text":" then ","type":"text"},{"code":"swift run storykit validate ~\/Downloads\/HauntedStarter --format text","type":"codeVoice"},{"text":". The output will list structural and content issues to fix.","type":"text"}]}],"type":"step","media":null,"code":"02-validate-errors.txt","runtimePreview":null}],"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The validator is exposed through the ","type":"text"},{"code":"storykit","type":"codeVoice"},{"text":" CLI. It loads either a source folder (containing ","type":"text"},{"code":"story.json","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"texts\/","type":"codeVoice"},{"text":") or a compiled bundle (containing ","type":"text"},{"code":"manifest.json","type":"codeVoice"},{"text":", ","type":"text"},{"code":"graph.json","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"texts\/","type":"codeVoice"},{"text":"). By default, the text output lists warnings and errors. JSON output includes counts and a serializable issue list, and the tool exits non‑zero on errors so you can use it in CI.","type":"text"}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}]},{"anchor":"Story-Node-Structure","title":"Story Node Structure","stepsSection":[{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Set the start node. The story engine needs to know which node to begin the story at, and you want to begin outside the house, so you set the starting node to ","type":"text"},{"code":"arrival_road","type":"codeVoice"},{"text":".","type":"text"}]}],"type":"step","media":null,"code":"03-after-with-start.json","runtimePreview":null},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Make duplicate choice ids unique. All choice ids under a node need to be unique. In the starter files, ","type":"text"},{"code":"to_dining","type":"codeVoice"},{"text":" appeared twice. Change one of them to ","type":"text"},{"code":"to_study","type":"codeVoice"},{"text":" so each choice has its own name.","type":"text"}]}],"type":"step","media":null,"code":"03-after-duplicate-choices.json","runtimePreview":null},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Fix the misspelled destination. A choice pointed to ","type":"text"},{"code":"end_succesful","type":"codeVoice"},{"text":". This looks like a simple typo — it’s missing an “S”. Correct it to ","type":"text"},{"code":"end_successful","type":"codeVoice"},{"text":" so the choice leads to a real node.","type":"text"}]}],"type":"step","media":null,"code":"03-after-dest-typo.json","runtimePreview":null},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Validate again after the JSON fixes. At this point the structure is sound; what remains are text issues in Markdown: a missing ","type":"text"},{"code":"dining_room","type":"codeVoice"},{"text":" section and an orphan ","type":"text"},{"code":"attic_extra","type":"codeVoice"},{"text":" section.","type":"text"}]}],"type":"step","media":null,"code":"03-validate-after-json.txt","runtimePreview":null}],"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The validator reported three structure problems in ","type":"text"},{"code":"story.json","type":"codeVoice"},{"text":":","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A missing "},{"code":"start","type":"codeVoice"},{"type":"text","text":" field: every story needs a “first page” so the engine knows where to begin."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A duplicate choice id under one node: two choices shared the same name, which makes it unclear which path the player picked."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A missing destination: a choice pointed to a node id that doesn’t exist — often a simple typo."}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Fix each issue below and validate after each change.","type":"text"}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}]},{"anchor":"Text-Content","title":"Text Content","stepsSection":[{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Restore the missing section and remove the orphan. Below is an excerpt of the corrected Markdown, with the ","type":"text"},{"code":"dining_room","type":"codeVoice"},{"text":" section present and the orphan removed.","type":"text"}]}],"type":"step","media":null,"code":"04-haunted-fixed.txt","runtimePreview":null},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Validate again. With these fixes applied, the report should be clean.","type":"text"}]}],"type":"step","media":null,"code":"04-validate-clean.txt","runtimePreview":null}],"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"With the graph repaired, turn to prose. The validator reported two Markdown issues:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A missing "},{"code":"dining_room","type":"codeVoice"},{"type":"text","text":" section: a node references prose that isn’t present; every node needs matching text."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An orphan "},{"code":"attic_extra","type":"codeVoice"},{"type":"text","text":" section: no node connects to it. It’s likely a left‑over from an encounter that was discarded, so remove the section completely."}]}]}],"type":"unorderedList"}],"kind":"contentAndMedia","mediaPosition":"trailing"}]},{"anchor":"Compile-the-Story","title":"Compile the Story","stepsSection":[{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Run the compiler and review the bundle structure. You can load this bundle at runtime with ","type":"text"},{"code":"StoryBundleLoader","type":"codeVoice"},{"text":".","type":"text"}]}],"type":"step","media":null,"code":"05-compile-command.txt","runtimePreview":null}],"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Compile the repaired source into a directory–based ","type":"text"},{"code":".storybundle","type":"codeVoice"},{"text":". The compiler copies your ","type":"text"},{"code":"texts\/","type":"codeVoice"},{"text":", writes a ","type":"text"},{"code":"manifest.json","type":"codeVoice"},{"text":" that records a hash of the graph for integrity checks, and saves the graph into ","type":"text"},{"code":"graph.json","type":"codeVoice"},{"text":". Apps load bundles with ","type":"text"},{"code":"StoryBundleLoader","type":"codeVoice"},{"text":".","type":"text"}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}]},{"anchor":"Outcome","title":"Outcome","stepsSection":[{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"You’re ready to move on to playing the story in Swift.","type":"text"}]}],"type":"step","media":null,"code":null,"runtimePreview":null}],"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"You now have a validated Haunted House story and a compiled ","type":"text"},{"code":".storybundle","type":"codeVoice"},{"text":" that mirrors your source. This is the foundation for the next tutorial, where you’ll load the bundle, create a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", and build a small CLI to read text and advance by choice. Each time you make changes to your story, run the validator again to ensure consistency and no unreachable areas.","type":"text"}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}]}],"kind":"tasks"},{"abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"type":"codeVoice","code":"StoryEngine"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"type":"codeVoice","code":"select(choiceID:)"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}],"kind":"callToAction","featuredEyebrow":"Tutorial","title":"Playing a Story with StoryEngine","action":{"type":"reference","overridingTitleInlineContent":[{"text":"Get started","type":"text"}],"overridingTitle":"Get started","isActive":true,"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift"}}],"references":{"doc://StoryKit/tutorials/table-of-contents/Playing-a-Story-with-StoryEngine":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Playing-a-Story-with-StoryEngine","title":"Playing a Story with StoryEngine","url":"\/tutorials\/table-of-contents\/playing-a-story-with-storyengine","role":"article","kind":"article","abstract":[]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Outcome":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Outcome","title":"Outcome","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Outcome","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Load-the-Story-Bundle","title":"Load the Story Bundle","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Load-the-Story-Bundle","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift","title":"Playing a Story with StoryEngine","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift","estimatedTime":"35min","role":"project","kind":"project","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},"03-after-duplicate-choices.json":{"content":["{","  \"id\": \"foyer\",","  \"choices\": [","    {\"id\": \"to_dining\", \"destination\": \"dining_room\"},","    {\"id\": \"to_study\", \"destination\": \"study\"},","    {\"id\": \"to_kitchen\", \"destination\": \"kitchen\"}","  ]","}",""],"type":"file","fileName":"unique ids","identifier":"03-after-duplicate-choices.json","fileType":"","syntax":"","highlights":[]},"03-after-dest-typo.json":{"type":"file","content":["{","  \"id\": \"ritual_chamber\",","  \"choices\": [","    {\"id\": \"attempt_ritual\", \"destination\": \"end_successful\"},","    {\"id\": \"falter\", \"destination\": \"end_dead\"},","    {\"id\": \"flee\", \"destination\": \"end_scarred_2\"}","  ]","}",""],"fileName":"fixed destination","identifier":"03-after-dest-typo.json","syntax":"","fileType":"","highlights":[]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Validating-a-Story":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Validating-a-Story","title":"Validating a Story","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Validating-a-Story","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Autosave-Between-Rounds","title":"Autosave Between Rounds","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Autosave-Between-Rounds","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Define-Minimal-State","title":"Define Minimal State","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Define-Minimal-State","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"text":", print the current node’s prose, enumerate available choices, and call ","type":"text"},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},"01-format-story.json":{"content":["{","  \"metadata\": { \"id\": \"example\", \"title\": \"Example\", \"version\": 1 },","  \"start\": \"start_node\",","  \"nodes\": {","    \"start_node\": { \"id\": \"start_node\", \"text\": {\"file\": \"haunted.md\", \"section\": \"start_node\"}, \"choices\": [","      {\"id\": \"go_next\", \"destination\": \"next\"}","    ]},","    \"next\": { \"id\": \"next\", \"text\": {\"file\": \"haunted.md\", \"section\": \"next\"}, \"choices\": [] }","  }","}",""],"type":"file","fileName":"story.json excerpt","identifier":"01-format-story.json","fileType":"","syntax":"","highlights":[]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Story-Node-Structure":{"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Story-Node-Structure","type":"section","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Story-Node-Structure","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}],"title":"Story Node Structure","kind":"section","role":"pseudoSymbol"},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Designing-Game-State","title":"Designing Game State","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Designing-Game-State","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks":{"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks","type":"topic","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks","abstract":[{"text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow.","type":"text"}],"title":"Checks, Effects, Actions, Battles, and the Ritual","kind":"project","role":"project","estimatedTime":"1hr 0min"},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Create-the-Engine-Print-Nodes","title":"Create the Engine & Print Nodes","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Create-the-Engine-Print-Nodes","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a ","type":"text"},{"code":"StoryEngine","type":"codeVoice"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"code":"select(choiceID:)","type":"codeVoice"},{"text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended.","type":"text"}]},"doc://StoryKit/tutorials/table-of-contents/Checks,-Effects,-Actions,-Battles,-and-the-Ritual":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Checks,-Effects,-Actions,-Battles,-and-the-Ritual","title":"Checks, Effects, Actions, Battles, and the Ritual","url":"\/tutorials\/table-of-contents\/checks,-effects,-actions,-battles,-and-the-ritual","role":"article","kind":"article","abstract":[]},"01-format-bundle.txt":{"type":"file","content":["HauntedHouseBundle\/","├── manifest.json","├── graph.json","└── texts\/","    └── haunted.md",""],"fileName":"storybundle tree","identifier":"01-format-bundle.txt","syntax":"","fileType":"","highlights":[]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Outcome":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Outcome","title":"Outcome","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Outcome","role":"pseudoSymbol","kind":"section","abstract":[{"text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation.","type":"text"}]},"doc://StoryKit/tutorials/table-of-contents":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents","url":"\/tutorials\/table-of-contents","title":"Meet StoryKit","role":"overview","kind":"overview","abstract":[{"type":"text","text":"StoryKit is a data‑driven engine and toolset for building branching, text‑forward experiences. These tutorials guide you from validating a story, to playing it with a small Swift app, to layering mechanics like checks, effects, and actions."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story","title":"Building and Validating a Story","estimatedTime":"30min","role":"project","kind":"project","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}]},"02-validate-errors.txt":{"type":"file","content":["Error: keyNotFound(CodingKeys(stringValue: \"start\", intValue: nil), Swift.DecodingError.Context(codingPath: [], debugDescription: \"No value associated with key CodingKeys(stringValue: \\\"start\\\", intValue: nil) (\\\"start\\\").\", underlyingError: nil))"],"fileName":"validator output (broken)","identifier":"02-validate-errors.txt","syntax":"","fileType":"","highlights":[]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Compile-the-Story":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Compile-the-Story","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Compile-the-Story","title":"Compile the Story","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}]},"01-format-haunted.txt":{"type":"file","content":["=== node: start_node ===","This is an example section. In real stories, each section contains the full prose for a node.","","=== node: next ===","The next node. Choices for this node would be declared in story.json.",""],"fileName":"haunted.md excerpt","identifier":"01-format-haunted.txt","syntax":"","fileType":"","highlights":[]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Roll-Under-Checks-Predicates","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Roll-Under-Checks-Predicates","title":"Roll-Under Checks & Predicates","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#StoryKit-File-Formats","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#StoryKit-File-Formats","title":"StoryKit File Formats","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Project-Setup","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Project-Setup","title":"Project Setup","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"code":"StoryEngine","type":"codeVoice"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"code":"select(choiceID:)","type":"codeVoice"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Outcome":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Outcome","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Outcome","title":"Outcome","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}]},"03-after-with-start.json":{"type":"file","content":["{","  \"metadata\": { \"id\": \"haunted_house\", \"title\": \"Haunted House\", \"version\": 1 },","  \"start\": \"arrival_road\",","  \"entities\": { \/* … *\/ },","  \"globals\": { \/* … *\/ },","  \"nodes\": { \/* … *\/ }","}"],"fileName":"start set","identifier":"03-after-with-start.json","syntax":"","fileType":"","highlights":[]},"03-validate-after-json.txt":{"type":"file","content":["- [ERROR] Missing text section 'dining_room' in file haunted.md","- [WARNING] Orphan text section 'attic_extra' in file haunted.md"],"fileName":"validator after JSON fixes","identifier":"03-validate-after-json.txt","syntax":"","fileType":"","highlights":[]},"04-haunted-fixed.txt":{"type":"file","content":["\/\/ Fixed haunted-final markdown (excerpt)","=== node: foyer ===","The double doors groan and yield. The foyer swallows you: cool, stale air, a chandelier filmed with dust, a checkered floor of black and white marble.","","=== node: dining_room ===","A long table sits beneath a clouded mirror. Place settings sleep beneath a veil of dust; a folded letter rests near the head of the table.","","\/\/ Removed orphaned attic_extra section",""],"fileName":"fixed haunted.md","identifier":"04-haunted-fixed.txt","syntax":"md","fileType":"md","highlights":[]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Ordered-Sequence":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#The-Final-Ritual-Ordered-Sequence","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#The-Final-Ritual-Ordered-Sequence","title":"The Final Ritual (Ordered Sequence)","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}]},"doc://StoryKit/tutorials/table-of-contents/Building-and-Validating-a-Story":{"type":"topic","identifier":"doc:\/\/StoryKit\/tutorials\/table-of-contents\/Building-and-Validating-a-Story","url":"\/tutorials\/table-of-contents\/building-and-validating-a-story","title":"Building and Validating a Story","role":"article","kind":"article","abstract":[]},"doc://StoryKit/tutorials/StoryKit/Tutorial-1-Building-Your-First-Story#Text-Content":{"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-1-Building-Your-First-Story#Text-Content","type":"section","url":"\/tutorials\/storykit\/tutorial-1-building-your-first-story#Text-Content","abstract":[{"type":"text","text":"In this tutorial you’ll get comfortable with the StoryKit authoring model and the validator that keeps your story graph honest. You’ll start from a small broken version of the Haunted House story and repair it step by step until it validates cleanly and compiles into a runtime‑ready bundle. Along the way, you’ll examine the on‑disk formats, run the CLI, and verify each fix by re‑running validation."}],"title":"Text Content","kind":"section","role":"pseudoSymbol"},"05-compile-command.txt":{"type":"file","content":["swift run storykit compile ~\/Downloads\/HauntedStarter --out HauntedHouse.storybundle","✅ Wrote bundle to \/path\/to\/HauntedHouse.storybundle"],"fileName":"compiler invocation","identifier":"05-compile-command.txt","syntax":"","fileType":"","highlights":[]},"04-validate-clean.txt":{"type":"file","content":["✅ No issues found"],"fileName":"validator clean","identifier":"04-validate-clean.txt","syntax":"","fileType":"","highlights":[]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Effects-Damage-Sanity-Items-Flags","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Effects-Damage-Sanity-Items-Flags","title":"Effects: Damage, Sanity, Items, Flags","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-3-Adding-State-and-Skill-Checks#Entities-Multi-Round-Battles-with-Flee":{"type":"section","identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-3-Adding-State-and-Skill-Checks#Entities-Multi-Round-Battles-with-Flee","url":"\/tutorials\/storykit\/tutorial-3-adding-state-and-skill-checks#Entities-Multi-Round-Battles-with-Flee","title":"Entities & Multi-Round Battles with Flee","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"In this tutorial you’ll enrich the minimal CLI from Tutorial 2 with game‑flavored mechanics: roll‑under d20 checks, health and sanity tracking, inventory and flags, predicates and effects to gate and mutate state, a simple multi‑round fight with flee, and an ordered ritual that branches to different endings. The emphasis is equal parts “why” and “how”: why these pieces fit the tone, and how to implement them using StoryKit’s registries and engine flow."}]},"doc://StoryKit/tutorials/StoryKit/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface":{"identifier":"doc:\/\/StoryKit\/tutorials\/StoryKit\/Tutorial-2-Playing-a-Story-in-Swift#Command-Line-Interface","type":"section","url":"\/tutorials\/storykit\/tutorial-2-playing-a-story-in-swift#Command-Line-Interface","abstract":[{"type":"text","text":"In this tutorial you will build a small command–line runner that loads the compiled Haunted House bundle and lets a player move through the narrative by choosing options. You will learn how to load a bundle, construct a "},{"code":"StoryEngine","type":"codeVoice"},{"type":"text","text":", print the current node’s prose, enumerate available choices, and call "},{"code":"select(choiceID:)","type":"codeVoice"},{"type":"text","text":" to advance. The result is a minimal, idiomatic Swift program that uses StoryKit as intended."}],"title":"Command-Line Interface","kind":"section","role":"pseudoSymbol"}}}