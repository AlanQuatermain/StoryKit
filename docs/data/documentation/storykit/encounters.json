{"variants":[{"paths":["\/documentation\/storykit\/encounters"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/StoryKit\/documentation\/StoryKit\/Encounters"},"kind":"article","primaryContentSections":[{"kind":"content","content":[{"level":2,"anchor":"Goals","type":"heading","text":"Goals"},{"items":[{"content":[{"inlineContent":[{"text":"Keep ","type":"text"},{"code":"story.json","type":"codeVoice"},{"text":" declarative: names\/ids\/tags only — no mechanics.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Let the client run encounters turn‑by‑turn without advancing the engine.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Provide global outcomes (e.g., “player died”) that can transition from anywhere.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":2,"anchor":"Data-Shape-content","type":"heading","text":"Data Shape (content)"},{"items":[{"content":[{"inlineContent":[{"text":"Top‑level ","type":"text"},{"code":"entities","type":"codeVoice"},{"text":": canonical entities to reference (labels\/tags\/art keys).","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Per‑node ","type":"text"},{"code":"actors","type":"codeVoice"},{"text":": which entities are present at the location.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Top‑level ","type":"text"},{"code":"globals.globalActions","type":"codeVoice"},{"text":": global outcomes mapping to destination nodes.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"code":["{","  \"entities\": { \"goblin\": { \"name\": \"Goblin\", \"tags\": [\"hostile\"] } },","  \"nodes\": {","    \"cellar\": { \"id\": \"cellar\", \"text\": {\"file\":\"t.md\",\"section\":\"cellar\"},","      \"actors\": [ { \"id\": \"g1\", \"ref\": \"goblin\" } ],","      \"choices\": [ { \"id\": \"fight\", \"title\": \"Fight\", \"destination\": \"cellar\" } ]","    }","  },","  \"globals\": { \"globalActions\": { \"playerDied\": { \"destination\": \"fail\" } } }","}"],"type":"codeListing","syntax":"json"},{"level":2,"anchor":"Minimal-Client-Implementation","type":"heading","text":"Minimal Client Implementation"},{"inlineContent":[{"text":"Define state that can hold an encounter sub‑state. Your app controls the rules.","type":"text"}],"type":"paragraph"},{"code":["import StoryKit","","struct EncounterState: Sendable, Codable {","    struct Participant: Sendable, Codable { var id: String; var hp: Int }","    var participants: [Participant]","    var turn: Int = 0","}","","struct GameState: StoryState {","    var currentNode: NodeID","    var activeEncounter: EncounterState? = nil","}","","enum BattleMove { case attack(targetID: String); case defend }"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Register actions that mutate ","type":"text"},{"type":"codeVoice","code":"GameState"},{"text":". Return values are for your UI; the engine does not advance nodes.","type":"text"}],"type":"paragraph"},{"code":["var actions = ActionRegistry<GameState>()","","actions.register(\"startEncounter\") { state, params in","    \/\/ Seed from current node's actors (or params). Mechanics are yours.","    guard state.activeEncounter == nil else { return .completed }","    let actorsHere = \/* resolve from story.nodes[state.currentNode].actors *\/ [] as [String]","    state.activeEncounter = EncounterState(","        participants: actorsHere.map { .init(id: $0, hp: 10) }, turn: 0","    )","    return .requiresUserInput(hint: \"encounter-begun\")","}","","actions.register(\"encounterTurn\") { state, params in","    guard var enc = state.activeEncounter else { return .completed }","    \/\/ Decode your move (String params -> your domain).","    let target = params[\"target\"] ?? \"\"","    \/\/ Apply your rules.","    if let i = enc.participants.firstIndex(where: { $0.id == target }) {","        enc.participants[i].hp -= 3","    }","    enc.turn += 1","    state.activeEncounter = enc","    return .requiresUserInput(hint: \"turn-complete\")","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Drive the UI loop while staying on the same node. When a terminal condition happens, trigger a global action.","type":"text"}],"type":"paragraph"},{"code":["let engine = StoryEngine(","    story: story,","    initialState: GameState(currentNode: story.start),","    actionRegistry: actions",")","","\/\/ Start encounter (e.g., on tapping a choice)","_ = try await engine.performAction(id: \"startEncounter\")","","\/\/ Turn loop (UI driven)","while let enc = await engine.state.activeEncounter, enc.participants.contains(where: { $0.hp > 0 }) {","    \/\/ Render UI from state.","    \/\/ On player input, call encounterTurn with parameters.","    _ = try await engine.performAction(id: \"encounterTurn\", parameters: [\"target\": \"g1\"]) \/\/ example","","    \/\/ Check terminal conditions and transition via a global action if needed.","    if \/* player HP <= 0 *\/ false {","        _ = try await engine.performGlobalAction(id: \"playerDied\")","        break","    }","}","","\/\/ On victory, your action\/logic can set flags and then normal choice selection can continue."],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Notes:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Actions run on the engine actor and autosave (if configured) after each call.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Global actions apply on‑enter effects of their destination and autosave, just like normal transitions.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Encode richer parameters by convention (e.g., JSON in a string) if you need more structure.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"metadata":{"modules":[{"name":"StoryKit"}],"roleHeading":"Article","title":"Encounters and Globals","role":"article"},"sections":[],"abstract":[{"type":"text","text":"Model multi‑step battles in your app while keeping content data‑only."}],"hierarchy":{"paths":[["doc:\/\/StoryKit\/documentation\/StoryKit"]]},"references":{"doc://StoryKit/documentation/StoryKit":{"identifier":"doc:\/\/StoryKit\/documentation\/StoryKit","title":"StoryKit","url":"\/documentation\/storykit","role":"collection","type":"topic","kind":"symbol","abstract":[{"text":"Build rich, data‑driven “choose your own adventure” experiences with a small, composable core and first‑class tooling.","type":"text"}]}}}